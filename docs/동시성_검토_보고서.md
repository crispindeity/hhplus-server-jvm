## ğŸ“œ ë™ì‹œì„± ê²€í†  ë³´ê³ ì„œ

### âš™ï¸ í™˜ê²½

- RestAssured + CompletableFuture ë¥¼ ì‚¬ìš©í•œ API ìš”ì²­ í…ŒìŠ¤íŠ¸
- ë™ì‹œ ìš”ì²­ ê±´ìˆ˜: 100ê±´

### ğŸ§ª í…ŒìŠ¤íŠ¸ ë°©ë²•

- ë™ì‹œì„± í…ŒìŠ¤íŠ¸ íŠ¹ì„± ìƒ í…ŒìŠ¤íŠ¸ ì§„í–‰ì— ì‹œê°„ì´ ì¡°ê¸ˆ ì†Œìš”ë˜ì–´ í‰ì†Œì—ëŠ” í…ŒìŠ¤íŠ¸ê°€ ë™ì‘í•˜ì§€ ì•Šë„ë¡ ì„¤ì •ë˜ì–´ ìˆìŠµë‹ˆë‹¤.  
ë™ì‹œì„± í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ì‹œ ì•„ë˜ ëª…ë ¹ì–´ë¥¼ í†µí•´ ì‹¤í–‰ ì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.(í˜¹ì€ ë™ì‹œì„± í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ `@Tag` ì–´ë…¸í…Œì´ì…˜ ì£¼ì„ ì²˜ë¦¬)

```bash
# ëŒ€ê¸°ì—´ ë°œê¸‰ ë™ì‹œì„± í…ŒìŠ¤íŠ¸
./gradlew test --tests "kr.hhplus.be.server.queuetoken.concurrency.EntryQueueConcurrencyTest" -PincludeConcurrencyTests=true
```

```bash
# í¬ì¸íŠ¸ ì¶©ì „ ë™ì‹œì„± í…ŒìŠ¤íŠ¸
./gradlew test --tests "kr.hhplus.be.server.pointwallet.concurrency.PointWalletConcurrencyTest" -PincludeConcurrencyTests=true
```

```bash
# ì¢Œì„ ì˜ˆì•½ ë™ì‹œì„± í…ŒìŠ¤íŠ¸
./gradlew test --tests "kr.hhplus.be.server.reservation.concurrency.ReservationConcurrencyTest" -PincludeConcurrencyTests=true
```

```bash
# ê²°ì œ ì²˜ë¦¬ ë™ì‹œì„± í…ŒìŠ¤íŠ¸
./gradlew test --tests "kr.hhplus.be.server.payment.concurrency.PaymentConcurrencyTest" -PincludeConcurrencyTests=true
```

### ğŸ”– ë™ì‹œì„± ê²€í† 

| ê¸°ëŠ¥        | ì¢…ë¥˜                     | ê¸°ì¤€                   |
|-----------|------------------------|----------------------|
| ëŒ€ê¸°ì—´ í† í° ë°œê¸‰ | DB ë¹„ê´€ì  ë½               | ëŒ€ê¸°ì—´ ìˆœì„œ ë³´ì¥, ê²½í•© ë°œìƒë¥  â¬†ï¸, ì¬ì‹œë„ â |
| í¬ì¸íŠ¸ ì¶©ì „    | DB ë‚™ê´€ì  ë½               | ê²½í•© ë°œìƒë¥  â¬‡ï¸, ì¬ì‹œë„ âœ…     |
| ì¢Œì„ ì˜ˆì•½     | DB ë‚™ê´€ì  ë½ -> Redis ë¶„ì‚° ë½ | ê²½í•© ë°œìƒë¥  â†—ï¸,  ì¬ì‹œë„ âœ…    |
| ê²°ì œ ì²˜ë¦¬     | DB ë‚™ê´€ì  ë½               | ê²½í•© ë°œìƒë¥  â¬‡ï¸,  ì¬ì‹œë„ â    |

## ğŸ“‹ ë™ì‹œì„± ë°œìƒ ê²€í† 

### 1ï¸âƒ£ ëŒ€ê¸°ì—´ í† í° ë°œê¸‰

#### ğŸš¨ë¬¸ì œ ì‹ë³„

```log
Expected :101
Actual   :36
```

- ë™ì‹œì„± í…ŒìŠ¤íŠ¸ë¥¼ í†µí•œ í…ŒìŠ¤íŠ¸ ê²°ê³¼ 100ë²ˆì˜ í† í° ìƒì„± ìš”ì²­ ì´í›„ ë‹¤ìŒ ìˆœë²ˆì€ 101ë²ˆì´ ë˜ì–´ì•¼ í•˜ì§€ë§Œ, 36ë²ˆìœ¼ë¡œ ë‚˜ì˜¤ê³  ìˆëŠ” ëª¨ìŠµ.

#### ğŸ” ë¶„ì„

```text
# ëŒ€ê¸°ì—´ í† í° ë°œê¸‰ ë¡œì§
í† í° ìƒì„± ìš”ì²­ -> ì´ë¯¸ ë°œê¸‰ ëœ í† í° ìœ ë¬´ í™•ì¸ -> í† í° ë‹¤ìŒ ìˆœë²ˆ ì¡°íšŒ -> í† í° ìƒì„± -> í† í° ì €ì¥
```

- í˜„ì¬ êµ¬í˜„ë˜ì–´ ìˆëŠ” ëŒ€ê¸°ì—´ í† í° ë°œê¸‰ ë¡œì§ íŠ¹ì„± ìƒ, ë™ì‹œì— ëŒ€ê¸°ì—´ í† í° ë°œê¸‰ ìš”ì²­ì´ ìˆëŠ” ê²½ìš° `queue_tokens` í…Œì´ë¸”ì˜ `queueNumber` ê°€ ë™ì‹œì„± ë¬¸ì œê°€
  ë°œìƒí•˜ì—¬ ìˆœì°¨ì ìœ¼ë¡œ ëŠ˜ì–´ë‚˜ì§€ ì•ŠëŠ” ë¬¸ì œ ë°œìƒ

#### ğŸŸ¢ í•´ê²° ë°©ì•ˆ

- ë™ì‹œì„± ë¬¸ì œê°€ ë°œìƒí•˜ê³  ìˆëŠ” ë¶€ë¶„ì„ í•´ê²°í•´ì•¼ í•˜ëŠ”ë°, ê·¼ë³¸ì ìœ¼ë¡œëŠ” í˜„ì¬ ëŒ€ê¸°ì—´ í† í° ë°œê¸‰ ë¡œì§ ìì²´ê°€ ì¡°ê¸ˆì€ ë¶€ì‹¤í•œê²ƒ ê°™ë‹¤. ì´ëŸ°ì‹ì˜ í† í° ë°œê¸‰ê³¼ ê²€ì¦ì€ ì„¤ê³„ìƒ ì¡°ê¸ˆì€ ì•„ì‰¬ìš´
  ë¶€ë¶„ì´ ì¡´ì¬í•˜ëŠ”ê²ƒ ê°™ë‹¤.
- ë‹¤ë§Œ, í˜„ì¬ ì„¤ê³„ë¥¼ ë³€ê²½í•˜ê¸°ì—ëŠ” ì¡°ê¸ˆ ì–´ë ¤ìš´ ë¶€ë¶„ë“¤ì´ ìˆê¸° ë•Œë¬¸ì— ë¬¸ì œ ìƒí™©ì„ ë¹ ë¥´ê²Œ í•´ê²°í•  ìˆ˜ ìˆëŠ” ë°©ë²•ìœ¼ë¡œ ì ‘ê·¼í•´ì•¼ í• ê²ƒ ê°™ë‹¤.

##### ğŸ” ë½

- í˜„ì¬ í† í° ë°œê¸‰ ë¡œì§ ìƒ, ìš”ì²­í•˜ëŠ” ëª¨ë“  ì¸ì›ì„ ëŒ€ìƒìœ¼ë¡œ í† í°ì„ ë°œê¸‰í•´ì•¼ í•˜ëŠ”ë° ì•„ë˜ ë¦¬ìŠ¤íŠ¸ë¥¼ ì²´í¬í•˜ë©° ì–´ë–¤ ë½ì„ ì‚¬ìš©í• ì§€ ê²°ì •í•´ì•¼í• ê²ƒ ê°™ë‹¤.

###### âœ… ë‚™ê´€ì  ë½ (Optimistic Lock)

- [ ] ë°ì´í„°ì— **ë™ì‹œì— ì ‘ê·¼í•´ ìˆ˜ì •í•˜ëŠ” ë¹ˆë„ê°€ ë‚®ë‹¤**
- [ ] ì¶©ëŒì´ ë°œìƒí•´ë„ **ì¬ì‹œë„í•˜ëŠ” ë¹„ìš©ì´ ë‚®ê±°ë‚˜ í—ˆìš©ëœë‹¤**

###### ğŸ”’ ë¹„ê´€ì  ë½ (Pessimistic Lock)

- [x] ë™ì‹œì— ë™ì¼ ë°ì´í„°ë¥¼ ìˆ˜ì •í•  ê°€ëŠ¥ì„±ì´ **ë†’ë‹¤**
- [x] ë°ì´í„° ì¶©ëŒ ë°œìƒ ì‹œ **ì¬ì‹œë„ë‚˜ ë¡¤ë°±ì´ ë³µì¡í•˜ê±°ë‚˜ ìœ„í—˜í•˜ë‹¤**


- ì²´í¬ ë¦¬ìŠ¤íŠ¸ í™•ì¸ ê²°ê³¼ ë¹„ê´€ì  ë½ì„ ì‚¬ìš©í•˜ëŠ”ê²Œ ì¢‹ì„ê²ƒ ê°™ë‹¤.

#### ğŸ¥• í•´ê²°
```kotlin
@Transactional
fun createEntryQueueToken(userId: UUID): String =
    Log.logging(logger) { log ->
        log["method"] = "createEntryQueueToken()"
        if (entryQueuePort.existsWaitingQueueToken(userId)) {
            throw QueueTokenException(ErrorCode.TOKEN_ALREADY_ISSUED, userId.toString())
        }
        val queueNumber: Int = entryQueuePort.getEntryQueueNextNumber()
        val entryQueueToken: String = jwtHelper.createJWT(userId, queueNumber)
        val queueToken =
            QueueToken(
                userId = userId,
                queueNumber = queueNumber,
                token = entryQueueToken
            )
        entryQueuePort.saveEntryQueueToken(queueToken)
        entryQueueToken
    }

@Query(
    value = """
            SELECT COALESCE(MAX(queue_number), 0) + 1
            FROM queue_tokens
        """,
    nativeQuery = true
)
fun findEntryQueueNextNumber(): Int
```
- í˜„ì¬ `Token` ë°œê¸‰ ë¡œì§ ìƒ `Lock`ì„ ì„¤ì •í•˜ê¸° ë§¤ìš° ì–´ë ¤ìš´ ìƒí™©, `getEntryQueueNextNumber()` ë©”ì„œë“œê°€ `SELECT COALESCE(MAX(queue_number), 0) + 1` ì¿¼ë¦¬ë¥¼ ì‚¬ìš©í•˜ëŠ”ë°  
í•´ë‹¹ ì¿¼ë¦¬ì˜ ê²½ìš°ëŠ” `Lock` ì„ ì„¤ì •í•  `Row` ê°€ ì¡´ì¬í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— `Table` ì „ì²´ì— `Lock` ì„ ì„¤ì •í•˜ê²Œ ë˜ëŠ”ë° ë™ì‹œ ìš”ì²­ì´ ë“¤ì–´ì˜¤ëŠ” ê²½ìš° í…Œì´ë¸” ì „ì²´ì— ì„¤ì •í•œ `Lock` ë•Œë¬¸ì— `DeadLock` ì´ ë°œìƒ  
ê²°êµ­ `QueueNumber` ë¥¼ ë³„ë„ë¡œ ì €ì¥í•˜ëŠ” í…Œì´ë¸”ì„ ë§Œë“¤ì–´ì„œ í•´ë‹¹ í…Œì´ë¸”ì˜ `Row` ì— `Lock` ì„ ê±¸ì–´ ë™ì‹œì„± ë¬¸ì œë¥¼ í•´ê²°
- ë™ì‹œì„±ì— ëŒ€í•œ ê²½í—˜ì´ ë¶€ì¡±í•˜ì—¬ ë°œìƒí•œ ë¬¸ì œë¡œ, ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„ ë¶€í„° êµ¬í˜„ ê¹Œì§€ ë™ì‹œì„±ì„ ê³ ë ¤í•˜ì§€ ì•Šê³  ì‘ì—… í–ˆê¸° ë•Œë¬¸ì— ì´ëŸ° ë¬¸ì œê°€ ë°œìƒ.
- `Redis`, `MQ` ë“±ì„ ì‚¬ìš©í–ˆë‹¤ë©´, ì¢€ ë” ì‰½ê²Œ í•´ê²°ì´ ë˜ì—ˆì„ê²ƒ ê°™ì§€ë§Œ ì§€ê¸ˆ ì£¼ì°¨ì—ì„œëŠ” `RDB` ë§Œ ì‚¬ìš©í•´ì•¼ í•˜ê¸°ë„ í•˜ê³ , ì–´ë–»ê²Œë“  í•´ê²°ì„ í•´ë³´ê³  ì‹¶ì–´ ë‹¤ì–‘í•œ ë°©ë²•ì„ ì‹œë„í•˜ë‹¤. í•´ë‹¹ ë°©ë²•ì„ í†µí•´ ë¬¸ì œ í•´ê²°

```kotlin
fun createEntryQueueToken(userId: UUID): String =
    Log.logging(logger) { log ->
        log["method"] = "createEntryQueueToken()"
        if (entryQueuePort.existsWaitingQueueToken(userId)) {
            throw QueueTokenException(ErrorCode.TOKEN_ALREADY_ISSUED, userId.toString())
        }
        transactional.run {
            val queueNumber: Int =
                entryQueuePort.getQueueNumberByIdForUpdate(NUMBER_ID)
            val entryQueueToken: String = jwtHelper.createJWT(userId, queueNumber)
            val queueToken =
                QueueToken(
                    userId = userId,
                    queueNumber = queueNumber,
                    token = entryQueueToken
                )
            entryQueuePort.saveEntryQueueToken(queueToken)
            entryQueuePort.incrementNextNumber(queueNumber + 1)
            entryQueueToken
        }
    }

internal interface EntryQueueNumberJpaRepository : JpaRepository<QueueNumberEntity, String> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT q FROM QueueNumberEntity q WHERE q.id = :id")
    fun findByIdForUpdate(
        @Param("id") id: String
    ): QueueNumberEntity?
}
```

- ë™ì‹œì„± ë¬¸ì œë¥¼ í•´ê²°í•œ ì½”ë“œ, `getQueueNumberByIdForUpdate()` ë©”ì„œë“œë¥¼ í†µí•´ ë¹„ê´€ì  ë½ ì´ ì„¤ì •ë˜ì–´ ìˆëŠ” `QueueNumbers` í…Œì´ë¸”ì—ì„œ `QueueNumber`ë¥¼ ì¡°íšŒ í›„  
í•´ë‹¹ ê°’ìœ¼ë¡œ `Token` ì„ ë°œê¸‰í•˜ê³  ì €ì¥í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ìˆ˜ì •

### 2ï¸âƒ£ í¬ì¸íŠ¸ ì¶©ì „

#### ğŸš¨ë¬¸ì œ ì‹ë³„

```log
expected: 100000L
 but was: 48000L
```

- ë™ì‹œì„± í…ŒìŠ¤íŠ¸ë¥¼ í†µí•´ 100 ê±´ì˜ 1000 í¬ì¸íŠ¸ ì¶©ì „ ìš”ì²­ ì‹œ 100,000 í¬ì¸íŠ¸ê°€ ìµœì¢… ë³´ìœ  í¬ì¸íŠ¸ê°€ ë˜ì–´ì•¼ í•˜ì§€ë§Œ, 48,000 í¬ì¸íŠ¸ë§Œ ë³´ìœ í•˜ê³  ìˆëŠ” ëª¨ìŠµ
- ë‹¹ì—°í•˜ê²Œë„, ë‚´ì—­ì˜ ê²½ìš°ëŠ” 100 ê±´ ëª¨ë‘ ë¬¸ì œ ì—†ì´ ì €ì¥ë˜ëŠ” ì¤‘

#### ğŸ” ë¶„ì„

```text
# í¬ì¸íŠ¸ ì¶©ì „ ë¡œì§
í¬ì¸íŠ¸ ì§€ê°‘ ì¡°íšŒ -> í¬ì¸íŠ¸ ì¶©ì „ -> í¬ì¸íŠ¸ ì§€ê°‘ ì—…ë°ì´íŠ¸ -> í¬ì¸íŠ¸ ë‚´ì—­ ì €ì¥ 
```

- í¬ì¸íŠ¸ ì§€ê°‘ ì¡°íšŒ -> í¬ì¸íŠ¸ ì¶©ì „ ì‚¬ì´ì—ì„œ ë™ì‹œì„± ë¬¸ì œê°€ ë°œìƒí•˜ê³  ìˆëŠ”ê²ƒìœ¼ë¡œ íŒë‹¨

#### ğŸŸ¢ í•´ê²° ë°©ì•ˆ

- í¬ì¸íŠ¸ ì§€ê°‘ ì¡°íšŒì— ë½ì„ ì„¤ì •í•˜ì—¬ ë™ì‹œì— ì¡°íšŒ í›„ ì—…ë°ì´íŠ¸ í•˜ëŠ” ë¬¸ì œë¥¼ ë°©ì§€í•˜ë©´ í•´ê²°ì´ ë ê²ƒ ê°™ë‹¤.

##### ğŸ” ë½

- ì•„ë˜ ì²´í¬ ë¦¬ìŠ¤íŠ¸ë¥¼ í†µí•´ ì–´ë–¤ ë½ì„ ì‚¬ìš©í• ì§€ ê²°ì •í•´ì•¼ í• ê²ƒ ê°™ë‹¤.  

###### âœ… ë‚™ê´€ì  ë½ (Optimistic Lock)

- [x] ë°ì´í„°ì— **ë™ì‹œì— ì ‘ê·¼í•´ ìˆ˜ì •í•˜ëŠ” ë¹ˆë„ê°€ ë‚®ë‹¤**
- [x] ì¶©ëŒì´ ë°œìƒí•´ë„ **ì¬ì‹œë„í•˜ëŠ” ë¹„ìš©ì´ ë‚®ê±°ë‚˜ í—ˆìš©ëœë‹¤**

###### ğŸ”’ ë¹„ê´€ì  ë½ (Pessimistic Lock)

- [ ] ë™ì‹œì— ë™ì¼ ë°ì´í„°ë¥¼ ìˆ˜ì •í•  ê°€ëŠ¥ì„±ì´ **ë†’ë‹¤**
- [ ] ë°ì´í„° ì¶©ëŒ ë°œìƒ ì‹œ **ì¬ì‹œë„ë‚˜ ë¡¤ë°±ì´ ë³µì¡í•˜ê±°ë‚˜ ìœ„í—˜í•˜ë‹¤**

- í¬ì¸íŠ¸ ì¶©ì „ì˜ ì¬ì‹œë„ ê´€ì ì—ì„œ ë‚™ê´€ì  ë½ì„ ì‚¬ìš©í•˜ëŠ”ê²Œ ì¢‹ì„ê²ƒ ê°™ë‹¤.

#### ğŸ¥• í•´ê²°

```kotlin
@Entity
@Table(name = "point_wallets")
internal class PointWalletEntity(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(nullable = false, length = 36)
    val userId: String,
    @Column(nullable = false)
    val balance: Long,
) : BaseEntity()
```

- ê¸°ì¡´ì—ëŠ” ë³„ë„ì˜ ë²„ì „ ê´€ë¦¬ë¥¼ ìœ„í•œ í”„ë¡œí¼í‹°ê°€ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ëª¨ìŠµ.

```kotlin
@Entity
@Table(name = "point_wallets")
internal class PointWalletEntity(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(nullable = false, length = 36)
    val userId: String,
    @Column(nullable = false)
    val balance: Long,
    @jakarta.persistence.Version
    @Column(nullable = false)
    var version: Version = Version(0)
) : BaseEntity()
```

- ë‚™ê´€ì  ë½ì„ ì‚¬ìš©í•˜ê¸° ìœ„í•´ `version` í”„ë¡œí¼í‹° ì¶”ê°€

```kotlin
@Service
internal class PointWalletService(
    private val userPort: UserPort,
    private val pointWalletPort: PointWalletPort,
    private val pointTransactionPort: PointTransactionPort,
    private val transactional: Transactional
) {
    private val logger: Logger = Log.getLogger(PointWalletService::class.java)

    companion object {
        const val MAX_RETRIES = 10
        const val BACKOFF_MILLIS = 50L
    }

    fun chargePoint(
        userId: UUID,
        amount: Long
    ): Long =
        Log.logging(logger) { log ->
            log["method"] = "chargePoint()"
            verifyUser(userId)

            repeat(MAX_RETRIES) { attempt ->
                try {
                    val chargedWallet: PointWallet =
                        transactional.run {
                            val foundWallet: PointWallet =
                                pointWalletPort.getWallet(userId)
                                    ?: throw PointWalletException(
                                        ErrorCode.NOT_FOUND_USER_POINT_WALLET
                                    )

                            val charged: PointWallet = foundWallet.chargePoint(amount)

                            pointWalletPort.update(charged)

                            pointTransactionPort.save(
                                PointTransaction(
                                    pointWalletId = charged.id,
                                    amount = amount,
                                    type = PointTransaction.Type.CHARGED
                                )
                            )
                            charged
                        }
                    return@logging chargedWallet.balance
                } catch (_: ObjectOptimisticLockingFailureException) {
                    log["retry_attempt"] = attempt + 1
                    Thread.sleep(BACKOFF_MILLIS)
                }
            }
            throw PointWalletException(ErrorCode.FAILED_RETRY, "chargePoint() retry fail")
        }
}
```

- ì„œë¹„ìŠ¤ ë¡œì§ ë˜í•œ ê²½í•© ë°œìƒ ì‹œ ë‚™ê´€ì  ë½ ì˜ˆì™¸ë¥¼ ìºì¹˜í•˜ê³ , í¬ì¸íŠ¸ ì¶©ì „ì„ ì¬ì‹œë„ í•˜ëŠ” ë¡œì§ì„ ì¶”ê°€

### 3ï¸âƒ£ ì¢Œì„ ì˜ˆì•½

#### ğŸš¨ë¬¸ì œ ì‹ë³„

- ë™ì¼í•œ ì¢Œì„ì— ëŒ€í•´ ë™ì‹œì— ì˜ˆì•½ ìš”ì²­ì´ ë°œìƒí•˜ëŠ” ê²½ìš° ì—¬ëŸ¬ ìœ ì €ì—ê²Œ ë™ì¼í•œ ì¢Œì„ì´ ì˜ˆì•½ ë˜ëŠ” ë¬¸ì œ ë°œìƒ

```log
Expecting empty but was: [1L]
```

- í…ŒìŠ¤íŠ¸ ì½”ë“œë¡œ ì¤‘ë³µëœ ì¢Œì„ì„ ì²´í¬ í–ˆì„ ë•Œ ë¹„ì–´ìˆëŠ” ê°’ì´ ë°˜í™˜ë˜ê¸°ë¥¼ ê¸°ëŒ€ í•˜ì§€ë§Œ `1` ë²ˆ ì¢Œì„ì— ëŒ€í•´ ì¤‘ë³µ ì˜ˆì•½ì´ ë˜ì–´ `1L` ì´ ë°˜í™˜ë˜ê³  ìˆëŠ” ìƒí™©

#### ğŸ” ë¶„ì„

```text
# ì¢Œì„ ì˜ˆì•½ ë¡œì§
ì½˜ì„œíŠ¸ ì¢Œì„ ì¡°íšŒ -> ì½˜ì„œíŠ¸ ìŠ¤ì¼€ì¥´ ì¡°íšŒ -> ì¢Œì„ ì ìœ  í™•ì¸ -> ì¢Œì„ ì¡ˆìœ  ìƒíƒœ ì—…ë°ì´íŠ¸ -> ì½˜ì„œíŠ¸ ì¢Œì„ ìƒíƒœ ì—…ë°ì´íŠ¸ -> ê²°ì œ ì •ë³´ ìƒì„± -> ì˜ˆì•½ ìƒì„±
```

#### ğŸŸ¢ í•´ê²° ë°©ì•ˆ

- ì½˜ì„œíŠ¸ ì¢Œì„ì„ ë™ì‹œì— ì¡°íšŒ í•œ í›„ ì˜ˆì•½í•˜ëŠ”ê²Œ ë¬¸ì œê°€ ë˜ëŠ” ë¶€ë¶„ì´ê¸° ë•Œë¬¸ì— ì½˜ì„œíŠ¸ ì¢Œì„ ì¡°íšŒ ìª½ì— ë½ì„ ì„¤ì •í•˜ë©´ ë ê²ƒ ê°™ë‹¤.

##### ğŸ” ë½

###### âœ… ë‚™ê´€ì  ë½ (Optimistic Lock)

- [x] ë°ì´í„°ì— **ë™ì‹œì— ì ‘ê·¼í•´ ìˆ˜ì •í•˜ëŠ” ë¹ˆë„ê°€ ë‚®ë‹¤**
- [ ] ì¶©ëŒì´ ë°œìƒí•´ë„ **ì¬ì‹œë„í•˜ëŠ” ë¹„ìš©ì´ ë‚®ê±°ë‚˜ í—ˆìš©ëœë‹¤**

###### ğŸ”’ ë¹„ê´€ì  ë½ (Pessimistic Lock)

- [ ] ë™ì‹œì— ë™ì¼ ë°ì´í„°ë¥¼ ìˆ˜ì •í•  ê°€ëŠ¥ì„±ì´ **ë†’ë‹¤**
- [ ] ë°ì´í„° ì¶©ëŒ ë°œìƒ ì‹œ **ì¬ì‹œë„ë‚˜ ë¡¤ë°±ì´ ë³µì¡í•˜ê±°ë‚˜ ìœ„í—˜í•˜ë‹¤**

- ìµœì´ˆ ìš”ì²­ ì´í›„ ìš”ì²­ì— ëŒ€í•´ì„œëŠ” ì „ë¶€ ì‹¤íŒ¨ ì²˜ë¦¬ë¥¼ í•˜ë©´ ë˜ëŠ”ë°, ë¹„ê´€ì  ë½ì„ ì‚¬ìš©í•˜ëŠ” ê²½ìš° ë¶ˆí•„ìš”í•œ ë°ì´í„°ë² ì´ìŠ¤ ë½ì´ ë°œìƒí•˜ê¸° ë•Œë¬¸ì— ë‚™ê´€ì  ë½ì„ ì´ìš©í•´ì„œ ë™ì‹œì„± ì´ìŠˆë¥¼ í•´ê²°í•˜ë©´ ë ê²ƒ ê°™ë‹¤.

#### ğŸ¥• í•´ê²°

```kotlin
@Entity
@Table(name = "concert_seats")
internal class ConcertSeatEntity(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(nullable = false)
    val scheduleId: Long,
    @Column(nullable = false)
    val seatId: Long,
    @Column(nullable = false)
    @Enumerated(EnumType.STRING)
    val status: Status,
) : BaseEntity() {
    enum class Status {
        HELD,
        AVAILABLE,
        RESERVED
    }
}
```

- ë³„ë„ì˜ ë²„ì „ ì²˜ë¦¬ê°€ ë˜ê³  ìˆëŠ” ì•ŠëŠ” ëª¨ìŠµ

```kotlin
@Entity
@Table(name = "concert_seats")
internal class ConcertSeatEntity(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(nullable = false)
    val scheduleId: Long,
    @Column(nullable = false)
    val seatId: Long,
    @Column(nullable = false)
    @Enumerated(EnumType.STRING)
    val status: Status,
    @jakarta.persistence.Version
    @Column(nullable = false)
    var version: Version
) : BaseEntity() {
    enum class Status {
        HELD,
        AVAILABLE,
        RESERVED
    }
}
```

- ë‚™ê´€ì  ë½ì„ ì‚¬ìš©í•˜ê¸° ìœ„í•´ ë²„ì „ í”„ë¡œí¼í‹° ì¶”ê°€

```kotlin
@Service
internal class ReservationService(
    private val seatHoldPort: SeatHoldPort,
    private val concertSeatPort: ConcertSeatPort,
    private val reservationPort: ReservationPort,
    private val paymentPort: PaymentPort,
    private val reservationContextLoader: ReservationContextLoader,
    private val transactional: Transactional
) {
    private val logger: Logger = Log.getLogger(ReservationService::class.java)

    fun makeReservation(
        date: LocalDate,
        concertSeatId: Long,
        userId: String
    ): MakeReservationResponse =
        Log.logging(logger) { log ->
            log["method"] = "makeReservation()"

            val userUUID: UUID = UUID.fromString(userId)
            try {
                transactional.run {
                    val context: ReservationContext =
                        reservationContextLoader.load(concertSeatId, date)

                    val heldSeat: ConcertSeat = context.concertSeat.held()

                    concertSeatPort.update(heldSeat)

                    seatHoldPort.save(
                        SeatHold(
                            concertSeatId = concertSeatId,
                            userId = userUUID
                        )
                    )
                    
                    // ...
                }
            } catch (_: ObjectOptimisticLockingFailureException) {
                log["concurrency"] = concertSeatId
                throw ConcertSeatException(ErrorCode.OPTIMISTIC_LOCKING_FAILURE)
            }
       }
}
```

- ë½ í”„ë¡œí¼í‹° ì¶”ê°€ í›„ ì½˜ì„œíŠ¸ ì¢Œì„ì„ ì¡°íšŒ í•˜ëŠ” ë¡œì§ì— ì¶©ëŒ ë°œìƒ ì‹œ í•´ë‹¹ ìš”ì²­ì€ ì‹¤íŒ¨ í•˜ë„ë¡ ì˜ˆì™¸ ì²˜ë¦¬ ë¡œì§ ì¶”ê°€

#### ğŸ”„ Redis ë¶„ì‚° ë½ìœ¼ë¡œ ì „í™˜

- DB ë‚™ê´€ì  ë½ì„ ì‚¬ìš©í•˜ë˜ ê¸°ì¡´ ë¡œì§ì—ì„œ Redis ë¶„ì‚° ë½ì„ ì‚¬ìš©í•˜ë„ë¡ ë³€ê²½

##### ë¶„ì‚° ë½ìœ¼ë¡œ ì „í™˜ í•˜ëŠ” ì´ìœ 

1. ì˜ˆì•½ ìƒì„± ë¡œì§ ì•ˆì—ì„œ ì—¬ëŸ¬ ë„ë©”ì¸ì´ ì—¬ëŸ¬ ë‹¨ê³„ì— ê±¸ì³ ìƒì„± ë˜ê±°ë‚˜, ìˆ˜ì •ë˜ê³  ìˆê¸° ë•Œë¬¸ì— (ì˜ˆì•½, ê²°ì œ, ì¢Œì„)
2. ë³µì¡í•œ íŠ¸ëœì ì…˜ì„ ë‹¨ìˆœí•˜ê²Œ ì²˜ë¦¬ í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì—
3. DB ë¶€í•˜ ê°ì†Œ, ëŒ€ê¸°ì—´ì˜ í¬ê¸°ê°€ ì»¤ì§ˆ ìˆ˜ë¡ ë°œìƒí•  ìˆ˜ ìˆëŠ” ê²½í•© ë°œìƒë¥ ì´ ë†’ì•„ì§ˆ ìˆ˜ ìˆê³ , ê·¸ë§Œí¼ DB ì— ë¶€í•˜ê°€ ë§ì´ ë°œìƒí•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì—

#### êµ¬í˜„

- í¸ë¦¬í•˜ê²Œ ë¶„ì‚° ë½ì„ ì ìš©ì‹œí‚¬ ìˆ˜ ìˆë„ë¡ AOP ë¥¼ í™œìš©

```kotlin
@Aspect
@Component
internal class RedisLocksAspect(
    private val redisson: RedissonClient,
    private val parser: SpelExpressionParser,
    private val parameterNameDiscoverer: DefaultParameterNameDiscoverer
) {
    private val logger: Logger = Log.getLogger(RedisLocksAspect::class.java)

    companion object {
        private const val PREFIX = "lock:"
    }

    @Around("@annotation(redisLocks)")
    fun redisLocks(
        joinPoint: ProceedingJoinPoint,
        redisLocks: RedisLocks
    ): Any? =
        Log.logging(logger) { log ->
            log["method"] = "redisLocks()"
            val method: Method = (joinPoint.signature as MethodSignature).method
            log["joinPoint"] = method.name
            val context =
                MethodBasedEvaluationContext(
                    joinPoint.target,
                    method,
                    joinPoint.args,
                    parameterNameDiscoverer
                )

            val keys: List<String> = resolveAndNormalizeKeys(redisLocks, context)
            val lock: RLock = createLock(keys, redisLocks.useMultiLock)

            if (!tryAcquire(lock, redisLocks.waitSeconds, redisLocks.leaseSeconds)) {
                log["lock.keys"] = keys
                if (redisLocks.waitSeconds == 0L) {
                    throw LockAcquisition(message = "keys: $keys")
                }
                throw RedisLockTimeoutException(message = "keys: $keys")
            }

            try {
                joinPoint.proceed()
            } finally {
                unlockSafely(lock)
            }
        }

    private fun resolveAndNormalizeKeys(
        redisLocks: RedisLocks,
        context: MethodBasedEvaluationContext
    ): List<String> {
        val raw: Set<String> =
            redisLocks.keys
                .flatMap { expression ->
                    when (val value = parser.parseExpression(expression).getValue(context)) {
                        null -> emptyList()
                        is String -> listOf(value)
                        is Collection<*> ->
                            value.map {
                                it?.toString() ?: throw SpelException(
                                    code = ErrorCode.NOT_VALUE_IN_EXPRESSION,
                                    message = expression
                                )
                            }

                        else -> throw SpelException(
                            code = ErrorCode.INVALID_RETURN_TYPE,
                            message = "$value"
                        )
                    }
                }.map { it.trim() }
                .filter { it.isNotEmpty() }
                .toSet()

        if (raw.isEmpty()) {
            throw RedissonException(code = ErrorCode.KEYS_IS_EMPTY)
        }
        val normalized: List<String> = raw.map { if (it.startsWith(PREFIX)) it else "$PREFIX$it" }
        return if (redisLocks.sortKeys) normalized.sorted() else normalized
    }

    private fun createLock(
        keys: List<String>,
        useMultiLock: Boolean
    ): RLock =
        if (useMultiLock && keys.size > 1) {
            val locks: Array<RLock> = keys.map { redisson.getLock(it) }.toTypedArray()
            redisson.getMultiLock(*locks)
        } else {
            redisson.getLock(keys.first())
        }

    private fun tryAcquire(
        lock: RLock,
        waitSeconds: Long,
        leaseSeconds: Long
    ): Boolean =
        if (leaseSeconds == 0L) {
            lock.tryLock(waitSeconds, TimeUnit.SECONDS)
        } else {
            lock.tryLock(waitSeconds, leaseSeconds, TimeUnit.SECONDS)
        }

    private fun unlockSafely(lock: RLock) {
        if (lock.isHeldByCurrentThread) {
            runCatching { lock.unlock() }
                .onFailure {
                    throw RedissonException(
                        code = ErrorCode.FAILED_TO_UNLOCK,
                        message = "lock: ${lock.name}"
                    )
                }
        }
    }
}
```

- SpEL(Spring Expression Language) ë¥¼ í™œìš©í•˜ì—¬, ë©”ì„œë“œì˜ íŒŒë¼ë¯¸í„° ì´ë¦„ê³¼ ê°’ì„ ê°€ì§€ê³  í‚¤ ê°’ìœ¼ë¡œ í™œìš©

```kotlin
// RedisLocks ì–´ë…¸í…Œì´ì…˜
@Target(AnnotationTarget.FUNCTION)
@Retention(AnnotationRetention.RUNTIME)
annotation class RedisLocks(
    val keys: Array<String>,            // í‚¤ ëª©ë¡
    val waitSeconds: Long = 2,          // ë½ ëŒ€ê¸° ì‹œê°„
    val leaseSeconds: Long = 0,         // ë½ ìœ ì§€ ì‹œê°„ (0ì¸ ê²½ìš° ì™€ì¹˜ë… í™œì„±í™”)
    val sortKeys: Boolean = false,      // í‚¤ ì •ë ¬ (ë°ë“œë½ ë°©ì§€)
    val useMultiLock: Boolean = false   // ë©€í‹° ë½ ìœ ë¬´
)

// Reservation Service ì—ì„œ ì‚¬ìš©
@RedisLocks(
    keys = ["'concertSeat:' + #concertSeatId"],
    waitSeconds = 0,
    leaseSeconds = 3 
)
fun makeReservation()
```

- ìµœì´ˆ ìš”ì²­ ì´í›„ ìš”ì²­ì€ ì‹¤íŒ¨í•˜ë„ë¡, waitSeconds ë¥¼ 0ìœ¼ë¡œ ì§€ì • 

### 4ï¸âƒ£ ì˜ˆì•½ ê²°ì œ

#### ğŸš¨ë¬¸ì œ ì‹ë³„

- ë™ì‹œì— ê²°ì œ ìš”ì²­ ì‹œ í•˜ë‚˜ì˜ ì˜ˆì•½ì— ì¤‘ë³µ ê²°ì œê°€ ë°œìƒí•  ê²ƒìœ¼ë¡œ ì˜ˆìƒ

#### ğŸ” ë¶„ì„

```text
# ì˜ˆì•½ ê²°ì œ ë¡œì§
ì˜ˆì•½ ë‚´ì—­ ì¡°íšŒ -> ê²°ì œ ëª©ë¡ ì¡°íšŒ -> í¬ì¸íŠ¸ ì°¨ê° -> í¬ì¸íŠ¸ ì—…ë°ì´íŠ¸ -> í¬ì¸íŠ¸ ë‚´ì—­ ì¶”ê°€ -> ê²°ì œ ìƒíƒœ ì—…ë°ì´íŠ¸ -> ì˜ˆì•½ ìƒíƒœ ì—…ë°ì´íŠ¸ -> ì½˜ì„œíŠ¸ ì¢Œì„ ìƒíƒœ ì—…ë°ì´íŠ¸ -> ì¢Œì„ ì ìœ  ì œê±° -> ëŒ€ê¸°ì—´ í† í° ìƒíƒœ ì—…ë°ì´íŠ¸
```

- í¬ì¸íŠ¸ ì—…ë°ì´íŠ¸ì—ì„œ ì´ì „ì— ì„¤ì •í•œ ë½ìœ¼ë¡œ ì¸í•´ ì¤‘ë³µ ê²°ì œëŠ” ë˜ê³  ìˆì§€ ì•Šë‹¤.
- ë‹¤ë§Œ, ê²°ì œìª½ì— ë™ì‹œì„± ì˜ˆì™¸ì— ëŒ€í•œ ì˜ˆì™¸ ì²˜ë¦¬ ë¡œì§ì´ ì—†ì–´ 500 ì—ëŸ¬ ë°œìƒìœ¼ë¡œ ë¶€ì í•©í•œ ê²°ì œ ì²˜ë¦¬ ì‘ë‹µ ë©”ì„¸ì§€ê°€ ë°œìƒí•˜ëŠ” ìƒí™©
- ì˜ˆì•½, ê²°ì œì— ë”°ë¥¸ ë™ì‹œì„± ë¬¸ì œë¥¼ í¬ì¸íŠ¸ ìª½ì—ì„œ ë™ì‹œì„± ì²˜ë¦¬ë¡œ ì¸í•´ í•´ê²°í•˜ê³  ë„˜ì–´ê°€ëŠ”ê²Œ ë§ëŠ”ê±¸ê¹Œ?? ì´ ë¶€ë¶„ì— ëŒ€í•´ì„œëŠ” ê³ ë¯¼ì´ í•„ìš”í• ê²ƒ ê°™ë‹¤.
  - í¬ì¸íŠ¸ë¡œë§Œ ë™ì‹œì„±ì´ í•´ê²°ë˜ì—ˆë‹¤ê³  ë„˜ì–´ê°€ê¸°ëŠ” ë¶€ì ì ˆí•œê²ƒ ê°™ë‹¤. ì˜ˆì™¸ ì±…ì„ì„ ë„˜ê¸°ëŠ”ê²ƒ ê°™ê¸°ë„ í•˜ê³ , í¬ì¸íŠ¸ë¡œ ë„˜ì–´ê°€ê¸° ì „ì— ë™ì‹œì„± ë¬¸ì œë¥¼ ë°œê²¬í•˜ê³  ì²˜ë¦¬í•˜ëŠ”ê²Œ ì¢‹ì€ ë°©í–¥ì¸ê²ƒ ê°™ë‹¤.

##### ğŸ” ë½

###### âœ… ë‚™ê´€ì  ë½ (Optimistic Lock)

- [x] ë°ì´í„°ì— **ë™ì‹œì— ì ‘ê·¼í•´ ìˆ˜ì •í•˜ëŠ” ë¹ˆë„ê°€ ë‚®ë‹¤**
- [ ] ì¶©ëŒì´ ë°œìƒí•´ë„ **ì¬ì‹œë„í•˜ëŠ” ë¹„ìš©ì´ ë‚®ê±°ë‚˜ í—ˆìš©ëœë‹¤**

###### ğŸ”’ ë¹„ê´€ì  ë½ (Pessimistic Lock)

- [ ] ë™ì‹œì— ë™ì¼ ë°ì´í„°ë¥¼ ìˆ˜ì •í•  ê°€ëŠ¥ì„±ì´ **ë†’ë‹¤**
- [ ] ë°ì´í„° ì¶©ëŒ ë°œìƒ ì‹œ **ì¬ì‹œë„ë‚˜ ë¡¤ë°±ì´ ë³µì¡í•˜ê±°ë‚˜ ìœ„í—˜í•˜ë‹¤**

- ìµœì´ˆ ìš”ì²­ ì´í›„ ìš”ì²­ì— ëŒ€í•´ì„œëŠ” ì „ë¶€ ì‹¤íŒ¨ ì²˜ë¦¬ë¥¼ í•˜ë©´ ë˜ëŠ”ë°, ë¹„ê´€ì  ë½ì„ ì‚¬ìš©í•˜ëŠ” ê²½ìš° ë¶ˆí•„ìš”í•œ ë°ì´í„°ë² ì´ìŠ¤ ë½ì´ ë°œìƒí•˜ê¸° ë•Œë¬¸ì— ë‚™ê´€ì  ë½ì„ ì´ìš©í•´ì„œ ë™ì‹œì„± ì´ìŠˆë¥¼ í•´ê²°í•˜ë©´ ë ê²ƒ ê°™ë‹¤.

#### ğŸŸ¢ í•´ê²° ë°©ì•ˆ

- ê²°ì œ, ì˜ˆì•½ì— ë‚™ê´€ì  ë½ì„ ì ìš©ì‹œì¼œ ì¤‘ë³µ ê²°ì œ ì²˜ë¦¬ê°€ ë˜ì§€ ì•Šë„ë¡ ê·¸ë¦¬ê³  ê²°ì œ, ì˜ˆì•½ ìª½ì—ì„œ ë™ì‹œì„± ë¬¸ì œë¥¼ í•´ê²°í•  ìˆë„ë¡ ì ìš© ì‹œí‚¤ëŠ” ë°©í–¥ìœ¼ë¡œ í•´ì•¼í• ê²ƒ ê°™ë‹¤.

#### ğŸ¥• í•´ê²°

- ì˜ˆì•½ê³¼ ê²°ì œìª½ì— ë²„ì „ í”„ë¡œí¼í‹°ë¥¼ ì¶”ê°€í•˜ì—¬ ë‚™ê´€ì  ë½ì„ ì ìš© ì‹œí‚¤ê³  ë™ì‹œì„± ë¬¸ì œ ë°œìƒ ì‹œ ìµœì´ˆ ìš”ì²­ì—ë§Œ ê²°ì œ ì²˜ë¦¬ê°€ ë˜ê³  ë‚˜ë¨¸ì§€ ìš”ì²­ì—ëŠ” ì‹¤íŒ¨í•˜ë„ë¡ ì˜ˆì™¸ ì²˜ë¦¬ ë¡œì§ ì¶”ê°€
