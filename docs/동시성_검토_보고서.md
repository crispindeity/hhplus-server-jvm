## 📜 동시성 검토 보고서

### ⚙️ 환경

- RestAssured + CompletableFuture 를 사용한 API 요청 테스트
- 동시 요청 건수: 100건

## 📋 동시성 발생 검토

### 1️⃣ 대기열 토큰 발급

#### 🚨문제 식별

```log
Expected :101
Actual   :36
```

- 동시성 테스트를 통한 테스트 결과 100번의 토큰 생성 요청 이후 다음 순번은 101번이 되어야 하지만, 36번으로 나오고 있는 모습.

#### 🔍 분석

```text
# 대기열 토큰 발급 로직
토큰 생성 요청 -> 이미 발급 된 토큰 유무 확인 -> 토큰 다음 순번 조회 -> 토큰 생성 -> 토큰 저장
```

- 현재 구현되어 있는 대기열 토큰 발급 로직 특성 상, 동시에 대기열 토큰 발급 요청이 있는 경우 `queue_tokens` 테이블의 `queueNumber` 가 동시성 문제가
  발생하여 순차적으로 늘어나지 않는 문제 발생

#### 🟢 해결 방안

- 동시성 문제가 발생하고 있는 부분을 해결해야 하는데, 근본적으로는 현재 대기열 토큰 발급 로직 자체가 조금은 부실한것 같다. 이런식의 토큰 발급과 검증은 설계상 조금은 아쉬운
  부분이 존재하는것 같다.
- 다만, 현재 설계를 변경하기에는 조금 어려운 부분들이 있기 때문에 문제 상황을 빠르게 해결할 수 있는 방법으로 접근해야 할것 같다.

##### 🔐 락

- 현재 토큰 발급 로직 상, 요청하는 모든 인원을 대상으로 토큰을 발급해야 하는데 아래 리스트를 체크하며 어떤 락을 사용할지 결정해야할것 같다.

###### ✅ 낙관적 락 (Optimistic Lock)

- [ ] 데이터에 **동시에 접근해 수정하는 빈도가 낮다**
- [ ] 충돌이 발생해도 **재시도하는 비용이 낮거나 허용된다**
- [ ] 시스템이 **높은 처리량과 응답 속도**를 우선시한다
- [ ] 정합성보다는 **처리량과 사용자 경험**이 더 중요하다
- [ ] 데드락(deadlock)이 절대 발생하지 않도록 해야 한다

###### 🔒 비관적 락 (Pessimistic Lock)

- [x] 동시에 동일 데이터를 수정할 가능성이 **높다**
- [x] 데이터 충돌 발생 시 **재시도나 롤백이 복잡하거나 위험하다**
- [x] 충돌이 발생하면 **사용자나 비즈니스에 직접적인 영향**이 있다.
- [x] 절대적인 데이터 정합성이 요구된다.
- [x] 요청 순서나 트랜잭션 순서를 **엄격하게 보장해야 한다**
- [x] 충돌 발생 시 예외 대신 **대기하도록 설계되어야 한다**


- 체크 리스트 확인 결과 비관적 락을 사용하는게 좋을것 같다.

#### 🥕 해결
```kotlin
@Transactional
fun createEntryQueueToken(userId: UUID): String =
    Log.logging(logger) { log ->
        log["method"] = "createEntryQueueToken()"
        if (entryQueuePort.existsWaitingQueueToken(userId)) {
            throw QueueTokenException(ErrorCode.TOKEN_ALREADY_ISSUED, userId.toString())
        }
        val queueNumber: Int = entryQueuePort.getEntryQueueNextNumber()
        val entryQueueToken: String = jwtHelper.createJWT(userId, queueNumber)
        val queueToken =
            QueueToken(
                userId = userId,
                queueNumber = queueNumber,
                token = entryQueueToken
            )
        entryQueuePort.saveEntryQueueToken(queueToken)
        entryQueueToken
    }

@Query(
    value = """
            SELECT COALESCE(MAX(queue_number), 0) + 1
            FROM queue_tokens
        """,
    nativeQuery = true
)
fun findEntryQueueNextNumber(): Int
```
- 현재 `Token` 발급 로직 상 `Lock`을 설정하기 매우 어려운 상황, `getEntryQueueNextNumber()` 메서드가 `SELECT COALESCE(MAX(queue_number), 0) + 1` 쿼리를 사용하는데  
해당 쿼리의 경우는 `Lock` 을 설정할 `Row` 가 존재하지 않기 때문에 `Table` 전체에 `Lock` 을 설정하게 되는데 동시 요청이 들어오는 경우 테이블 전체에 설정한 `Lock` 때문에 `DeadLock` 이 발생  
결국 `QueueNumber` 를 별도로 저장하는 테이블을 만들어서 해당 테이블의 `Row` 에 `Lock` 을 걸어 동시성 문제를 해결
- 동시성에 대한 경험이 부족하여 발생한 문제로, 데이터베이스 설계 부터 구현 까지 동시성을 고려하지 않고 작업 했기 때문에 이런 문제가 발생.
- `Redis`, `MQ` 등을 사용했다면, 좀 더 쉽게 해결이 되었을것 같지만 지금 주차에서는 `RDB` 만 사용해야 하기도 하고, 어떻게든 해결을 해보고 싶어 다양한 방법을 시도하다. 해당 방법을 통해 문제 해결

```kotlin
fun createEntryQueueToken(userId: UUID): String =
    Log.logging(logger) { log ->
        log["method"] = "createEntryQueueToken()"
        if (entryQueuePort.existsWaitingQueueToken(userId)) {
            throw QueueTokenException(ErrorCode.TOKEN_ALREADY_ISSUED, userId.toString())
        }
        transactional.run {
            val queueNumber: Int =
                entryQueuePort.getQueueNumberByIdForUpdate(NUMBER_ID)
            val entryQueueToken: String = jwtHelper.createJWT(userId, queueNumber)
            val queueToken =
                QueueToken(
                    userId = userId,
                    queueNumber = queueNumber,
                    token = entryQueueToken
                )
            entryQueuePort.saveEntryQueueToken(queueToken)
            entryQueuePort.incrementNextNumber(queueNumber + 1)
            entryQueueToken
        }
    }

internal interface EntryQueueNumberJpaRepository : JpaRepository<QueueNumberEntity, String> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT q FROM QueueNumberEntity q WHERE q.id = :id")
    fun findByIdForUpdate(
        @Param("id") id: String
    ): QueueNumberEntity?
}
```

- 동시성 문제를 해결한 코드, `getQueueNumberByIdForUpdate()` 메서드를 통해 비관적 락 이 설정되어 있는 `QueueNumbers` 테이블에서 `QueueNumber`를 조회 후  
해당 값으로 `Token` 을 발급하고 저장하는 방식으로 수정

### 2️⃣ 포인트 충전

#### 🚨문제 식별

```log
expected: 100000L
 but was: 48000L
```

- 동시성 테스트를 통해 100 건의 1000 포인트 충전 요청 시 100,000 포인트가 최종 보유 포인트가 되어야 하지만, 48,000 포인트만 보유하고 있는 모습
- 당연하게도, 내역의 경우는 100 건 모두 문제 없이 저장되는 중

#### 🔍 분석

```text
# 포인트 충전 로직
포인트 지갑 조회 -> 포인트 충전 -> 포인트 지갑 업데이트 -> 포인트 내역 저장 
```

- 포인트 지갑 조회 -> 포인트 충전 사이에서 동시성 문제가 발생하고 있는것으로 판단

#### 🟢 해결 방안

- 포인트 지갑 조회에 락을 설정하여 동시에 조회 후 업데이트 하는 문제를 방지하면 해결이 될것 같다.

##### 🔐 락

- 아래 체크 리스트를 통해 어떤 락을 사용할지 결정해야 할것 같다.  

###### ✅ 낙관적 락 (Optimistic Lock)

- [x] 데이터에 **동시에 접근해 수정하는 빈도가 낮다**
- [x] 충돌이 발생해도 **재시도하는 비용이 낮거나 허용된다**
- [ ] 시스템이 **높은 처리량과 응답 속도**를 우선시한다
- [ ] 정합성보다는 **처리량과 사용자 경험**이 더 중요하다
- [ ] 데드락(deadlock)이 절대 발생하지 않도록 해야 한다

###### 🔒 비관적 락 (Pessimistic Lock)

- [ ] 동시에 동일 데이터를 수정할 가능성이 **높다**
- [ ] 데이터 충돌 발생 시 **재시도나 롤백이 복잡하거나 위험하다**
- [x] 충돌이 발생하면 **사용자나 비즈니스에 직접적인 영향**이 있다.
- [ ] 절대적인 데이터 정합성이 요구된다.
- [ ] 요청 순서나 트랜잭션 순서를 **엄격하게 보장해야 한다**
- [ ] 충돌 발생 시 예외 대신 **대기하도록 설계되어야 한다**

- 포인트 충전의 재시도 관점에서 낙관적 락을 사용하는게 좋을것 같다.

#### 🥕 해결

```kotlin
@Entity
@Table(name = "point_wallets")
internal class PointWalletEntity(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(nullable = false, length = 36)
    val userId: String,
    @Column(nullable = false)
    val balance: Long,
) : BaseEntity()
```

- 기존에는 별도의 버전 관리를 위한 프로퍼티가 존재하지 않는 모습.

```kotlin
@Entity
@Table(name = "point_wallets")
internal class PointWalletEntity(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(nullable = false, length = 36)
    val userId: String,
    @Column(nullable = false)
    val balance: Long,
    @jakarta.persistence.Version
    @Column(nullable = false)
    var version: Version = Version(0)
) : BaseEntity()
```

- 낙관적 락을 사용하기 위해 `version` 프로퍼티 추가

```kotlin
@Service
internal class PointWalletService(
    private val userPort: UserPort,
    private val pointWalletPort: PointWalletPort,
    private val pointTransactionPort: PointTransactionPort,
    private val transactional: Transactional
) {
    private val logger: Logger = Log.getLogger(PointWalletService::class.java)

    companion object {
        const val MAX_RETRIES = 10
        const val BACKOFF_MILLIS = 50L
    }

    fun chargePoint(
        userId: UUID,
        amount: Long
    ): Long =
        Log.logging(logger) { log ->
            log["method"] = "chargePoint()"
            verifyUser(userId)

            repeat(MAX_RETRIES) { attempt ->
                try {
                    val chargedWallet: PointWallet =
                        transactional.run {
                            val foundWallet: PointWallet =
                                pointWalletPort.getWallet(userId)
                                    ?: throw PointWalletException(
                                        ErrorCode.NOT_FOUND_USER_POINT_WALLET
                                    )

                            val charged: PointWallet = foundWallet.chargePoint(amount)

                            pointWalletPort.update(charged)

                            pointTransactionPort.save(
                                PointTransaction(
                                    pointWalletId = charged.id,
                                    amount = amount,
                                    type = PointTransaction.Type.CHARGED
                                )
                            )
                            charged
                        }
                    return@logging chargedWallet.balance
                } catch (_: ObjectOptimisticLockingFailureException) {
                    log["retry_attempt"] = attempt + 1
                    Thread.sleep(BACKOFF_MILLIS)
                }
            }
            throw PointWalletException(ErrorCode.FAILED_RETRY, "chargePoint() retry fail")
        }
}
```

- 서비스 로직 또한 경합 발생 시 낙관적 락 예외를 캐치하고, 포인트 충전을 재시도 하는 로직을 추가

### 3️⃣ 좌석 예약

#### 🚨문제 식별

- 동일한 좌석에 대해 동시에 예약 요청이 발생하는 경우 여러 유저에게 동일한 좌석이 예약 되는 문제 발생

```log
Expecting empty but was: [1L]
```

- 테스트 코드로 중복된 좌석을 체크 했을 때 비어있는 값이 반환되기를 기대 하지만 `1` 번 좌석에 대해 중복 예약이 되어 `1L` 이 반환되고 있는 상황

#### 🔍 분석

```text
# 좌석 예약 로직
콘서트 좌석 조회 -> 콘서트 스케쥴 조회 -> 좌석 점유 확인 -> 좌석 졈유 상태 업데이트 -> 콘서트 좌석 상태 업데이트 -> 결제 정보 생성 -> 예약 생성
```

#### 🟢 해결 방안

- 콘서트 좌석을 동시에 조회 한 후 예약하는게 문제가 되는 부분이기 때문에 콘서트 좌석 조회 쪽에 락을 설정하면 될것 같다.

##### 🔐 락

###### ✅ 낙관적 락 (Optimistic Lock)

- [x] 데이터에 **동시에 접근해 수정하는 빈도가 낮다**
- [ ] 충돌이 발생해도 **재시도하는 비용이 낮거나 허용된다**
- [x] 시스템이 **높은 처리량과 응답 속도**를 우선시한다
- [x] 정합성보다는 **처리량과 사용자 경험**이 더 중요하다
- [x] 데드락(deadlock)이 절대 발생하지 않도록 해야 한다

###### 🔒 비관적 락 (Pessimistic Lock)

- [ ] 동시에 동일 데이터를 수정할 가능성이 **높다**
- [ ] 데이터 충돌 발생 시 **재시도나 롤백이 복잡하거나 위험하다**
- [ ] 충돌이 발생하면 **사용자나 비즈니스에 직접적인 영향**이 있다.
- [ ] 절대적인 데이터 정합성이 요구된다.
- [ ] 요청 순서나 트랜잭션 순서를 **엄격하게 보장해야 한다**
- [ ] 충돌 발생 시 예외 대신 **대기하도록 설계되어야 한다**

- 최초 요청 이후 요청에 대해서는 전부 실패 처리를 하면 되는데, 비관적 락을 사용하는 경우 불필요한 데이터베이스 락이 발생하기 때문에 낙관적 락을 이용해서 동시성 이슈를 해결하면 될것 같다.

#### 🥕 해결

```kotlin
@Entity
@Table(name = "concert_seats")
internal class ConcertSeatEntity(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(nullable = false)
    val scheduleId: Long,
    @Column(nullable = false)
    val seatId: Long,
    @Column(nullable = false)
    @Enumerated(EnumType.STRING)
    val status: Status,
) : BaseEntity() {
    enum class Status {
        HELD,
        AVAILABLE,
        RESERVED
    }
}
```

- 별도의 버전 처리가 되고 있는 않는 모습

```kotlin
@Entity
@Table(name = "concert_seats")
internal class ConcertSeatEntity(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(nullable = false)
    val scheduleId: Long,
    @Column(nullable = false)
    val seatId: Long,
    @Column(nullable = false)
    @Enumerated(EnumType.STRING)
    val status: Status,
    @jakarta.persistence.Version
    @Column(nullable = false)
    var version: Version
) : BaseEntity() {
    enum class Status {
        HELD,
        AVAILABLE,
        RESERVED
    }
}
```

- 낙관적 락을 사용하기 위해 버전 프로퍼티 추가

```kotlin
@Service
internal class ReservationService(
    private val seatHoldPort: SeatHoldPort,
    private val concertSeatPort: ConcertSeatPort,
    private val reservationPort: ReservationPort,
    private val paymentPort: PaymentPort,
    private val reservationContextLoader: ReservationContextLoader,
    private val transactional: Transactional
) {
    private val logger: Logger = Log.getLogger(ReservationService::class.java)

    fun makeReservation(
        date: LocalDate,
        concertSeatId: Long,
        userId: String
    ): MakeReservationResponse =
        Log.logging(logger) { log ->
            log["method"] = "makeReservation()"

            val userUUID: UUID = UUID.fromString(userId)
            try {
                transactional.run {
                    val context: ReservationContext =
                        reservationContextLoader.load(concertSeatId, date)

                    val heldSeat: ConcertSeat = context.concertSeat.held()

                    concertSeatPort.update(heldSeat)

                    seatHoldPort.save(
                        SeatHold(
                            concertSeatId = concertSeatId,
                            userId = userUUID
                        )
                    )
                    
                    // ...
                }
            } catch (_: ObjectOptimisticLockingFailureException) {
                log["concurrency"] = concertSeatId
                throw ConcertSeatException(ErrorCode.OPTIMISTIC_LOCKING_FAILURE)
            }
       }
}
```

- 락 프로퍼티 추가 후 콘서트 좌석을 조회 하는 로직에 충돌 발생 시 해당 요청은 실패 하도록 예외 처리 로직 추가
