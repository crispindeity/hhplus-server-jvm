## 📜 동시성 검토 보고서

### ⚙️ 환경

- RestAssured + CompletableFuture 를 사용한 API 요청 테스트
- 동시 요청 건수: 100건

### 🧪 테스트 방법

- 동시성 테스트 특성 상 테스트 진행에 시간이 조금 소요되어 평소에는 테스트가 동작하지 않도록 설정되어 있습니다.  
동시성 테스트 실행 시 아래 명령어를 통해 실행 시킬 수 있습니다.(혹은 동시성 테스트 클래스 `@Tag` 어노테이션 주석 처리)

```bash
# 대기열 발급 동시성 테스트
./gradlew test --tests "kr.hhplus.be.server.queuetoken.concurrency.EntryQueueConcurrencyTest" -PincludeConcurrencyTests=true
```

```bash
# 포인트 충전 동시성 테스트
./gradlew test --tests "kr.hhplus.be.server.pointwallet.concurrency.PointWalletConcurrencyTest" -PincludeConcurrencyTests=true
```

```bash
# 좌석 예약 동시성 테스트
./gradlew test --tests "kr.hhplus.be.server.reservation.concurrency.ReservationConcurrencyTest" -PincludeConcurrencyTests=true
```

```bash
# 결제 처리 동시성 테스트
./gradlew test --tests "kr.hhplus.be.server.payment.concurrency.PaymentConcurrencyTest" -PincludeConcurrencyTests=true
```

### 🔖 동시성 검토

| 기능        | 종류                     | 기준                   |
|-----------|------------------------|----------------------|
| 대기열 토큰 발급 | DB 비관적 락               | 대기열 순서 보장, 경합 발생률 ⬆️, 재시도 ❎ |
| 포인트 충전    | DB 낙관적 락               | 경합 발생률 ⬇️, 재시도 ✅     |
| 좌석 예약     | DB 낙관적 락 -> Redis 분산 락 | 경합 발생률 ↗️,  재시도 ✅    |
| 결제 처리     | DB 낙관적 락               | 경합 발생률 ⬇️,  재시도 ❎    |

## 📋 동시성 발생 검토

### 1️⃣ 대기열 토큰 발급

#### 🚨문제 식별

```log
Expected :101
Actual   :36
```

- 동시성 테스트를 통한 테스트 결과 100번의 토큰 생성 요청 이후 다음 순번은 101번이 되어야 하지만, 36번으로 나오고 있는 모습.

#### 🔍 분석

```text
# 대기열 토큰 발급 로직
토큰 생성 요청 -> 이미 발급 된 토큰 유무 확인 -> 토큰 다음 순번 조회 -> 토큰 생성 -> 토큰 저장
```

- 현재 구현되어 있는 대기열 토큰 발급 로직 특성 상, 동시에 대기열 토큰 발급 요청이 있는 경우 `queue_tokens` 테이블의 `queueNumber` 가 동시성 문제가
  발생하여 순차적으로 늘어나지 않는 문제 발생

#### 🟢 해결 방안

- 동시성 문제가 발생하고 있는 부분을 해결해야 하는데, 근본적으로는 현재 대기열 토큰 발급 로직 자체가 조금은 부실한것 같다. 이런식의 토큰 발급과 검증은 설계상 조금은 아쉬운
  부분이 존재하는것 같다.
- 다만, 현재 설계를 변경하기에는 조금 어려운 부분들이 있기 때문에 문제 상황을 빠르게 해결할 수 있는 방법으로 접근해야 할것 같다.

##### 🔐 락

- 현재 토큰 발급 로직 상, 요청하는 모든 인원을 대상으로 토큰을 발급해야 하는데 아래 리스트를 체크하며 어떤 락을 사용할지 결정해야할것 같다.

###### ✅ 낙관적 락 (Optimistic Lock)

- [ ] 데이터에 **동시에 접근해 수정하는 빈도가 낮다**
- [ ] 충돌이 발생해도 **재시도하는 비용이 낮거나 허용된다**

###### 🔒 비관적 락 (Pessimistic Lock)

- [x] 동시에 동일 데이터를 수정할 가능성이 **높다**
- [x] 데이터 충돌 발생 시 **재시도나 롤백이 복잡하거나 위험하다**


- 체크 리스트 확인 결과 비관적 락을 사용하는게 좋을것 같다.

#### 🥕 해결
```kotlin
@Transactional
fun createEntryQueueToken(userId: UUID): String =
    Log.logging(logger) { log ->
        log["method"] = "createEntryQueueToken()"
        if (entryQueuePort.existsWaitingQueueToken(userId)) {
            throw QueueTokenException(ErrorCode.TOKEN_ALREADY_ISSUED, userId.toString())
        }
        val queueNumber: Int = entryQueuePort.getEntryQueueNextNumber()
        val entryQueueToken: String = jwtHelper.createJWT(userId, queueNumber)
        val queueToken =
            QueueToken(
                userId = userId,
                queueNumber = queueNumber,
                token = entryQueueToken
            )
        entryQueuePort.saveEntryQueueToken(queueToken)
        entryQueueToken
    }

@Query(
    value = """
            SELECT COALESCE(MAX(queue_number), 0) + 1
            FROM queue_tokens
        """,
    nativeQuery = true
)
fun findEntryQueueNextNumber(): Int
```
- 현재 `Token` 발급 로직 상 `Lock`을 설정하기 매우 어려운 상황, `getEntryQueueNextNumber()` 메서드가 `SELECT COALESCE(MAX(queue_number), 0) + 1` 쿼리를 사용하는데  
해당 쿼리의 경우는 `Lock` 을 설정할 `Row` 가 존재하지 않기 때문에 `Table` 전체에 `Lock` 을 설정하게 되는데 동시 요청이 들어오는 경우 테이블 전체에 설정한 `Lock` 때문에 `DeadLock` 이 발생  
결국 `QueueNumber` 를 별도로 저장하는 테이블을 만들어서 해당 테이블의 `Row` 에 `Lock` 을 걸어 동시성 문제를 해결
- 동시성에 대한 경험이 부족하여 발생한 문제로, 데이터베이스 설계 부터 구현 까지 동시성을 고려하지 않고 작업 했기 때문에 이런 문제가 발생.
- `Redis`, `MQ` 등을 사용했다면, 좀 더 쉽게 해결이 되었을것 같지만 지금 주차에서는 `RDB` 만 사용해야 하기도 하고, 어떻게든 해결을 해보고 싶어 다양한 방법을 시도하다. 해당 방법을 통해 문제 해결

```kotlin
fun createEntryQueueToken(userId: UUID): String =
    Log.logging(logger) { log ->
        log["method"] = "createEntryQueueToken()"
        if (entryQueuePort.existsWaitingQueueToken(userId)) {
            throw QueueTokenException(ErrorCode.TOKEN_ALREADY_ISSUED, userId.toString())
        }
        transactional.run {
            val queueNumber: Int =
                entryQueuePort.getQueueNumberByIdForUpdate(NUMBER_ID)
            val entryQueueToken: String = jwtHelper.createJWT(userId, queueNumber)
            val queueToken =
                QueueToken(
                    userId = userId,
                    queueNumber = queueNumber,
                    token = entryQueueToken
                )
            entryQueuePort.saveEntryQueueToken(queueToken)
            entryQueuePort.incrementNextNumber(queueNumber + 1)
            entryQueueToken
        }
    }

internal interface EntryQueueNumberJpaRepository : JpaRepository<QueueNumberEntity, String> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT q FROM QueueNumberEntity q WHERE q.id = :id")
    fun findByIdForUpdate(
        @Param("id") id: String
    ): QueueNumberEntity?
}
```

- 동시성 문제를 해결한 코드, `getQueueNumberByIdForUpdate()` 메서드를 통해 비관적 락 이 설정되어 있는 `QueueNumbers` 테이블에서 `QueueNumber`를 조회 후  
해당 값으로 `Token` 을 발급하고 저장하는 방식으로 수정

### 2️⃣ 포인트 충전

#### 🚨문제 식별

```log
expected: 100000L
 but was: 48000L
```

- 동시성 테스트를 통해 100 건의 1000 포인트 충전 요청 시 100,000 포인트가 최종 보유 포인트가 되어야 하지만, 48,000 포인트만 보유하고 있는 모습
- 당연하게도, 내역의 경우는 100 건 모두 문제 없이 저장되는 중

#### 🔍 분석

```text
# 포인트 충전 로직
포인트 지갑 조회 -> 포인트 충전 -> 포인트 지갑 업데이트 -> 포인트 내역 저장 
```

- 포인트 지갑 조회 -> 포인트 충전 사이에서 동시성 문제가 발생하고 있는것으로 판단

#### 🟢 해결 방안

- 포인트 지갑 조회에 락을 설정하여 동시에 조회 후 업데이트 하는 문제를 방지하면 해결이 될것 같다.

##### 🔐 락

- 아래 체크 리스트를 통해 어떤 락을 사용할지 결정해야 할것 같다.  

###### ✅ 낙관적 락 (Optimistic Lock)

- [x] 데이터에 **동시에 접근해 수정하는 빈도가 낮다**
- [x] 충돌이 발생해도 **재시도하는 비용이 낮거나 허용된다**

###### 🔒 비관적 락 (Pessimistic Lock)

- [ ] 동시에 동일 데이터를 수정할 가능성이 **높다**
- [ ] 데이터 충돌 발생 시 **재시도나 롤백이 복잡하거나 위험하다**

- 포인트 충전의 재시도 관점에서 낙관적 락을 사용하는게 좋을것 같다.

#### 🥕 해결

```kotlin
@Entity
@Table(name = "point_wallets")
internal class PointWalletEntity(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(nullable = false, length = 36)
    val userId: String,
    @Column(nullable = false)
    val balance: Long,
) : BaseEntity()
```

- 기존에는 별도의 버전 관리를 위한 프로퍼티가 존재하지 않는 모습.

```kotlin
@Entity
@Table(name = "point_wallets")
internal class PointWalletEntity(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(nullable = false, length = 36)
    val userId: String,
    @Column(nullable = false)
    val balance: Long,
    @jakarta.persistence.Version
    @Column(nullable = false)
    var version: Version = Version(0)
) : BaseEntity()
```

- 낙관적 락을 사용하기 위해 `version` 프로퍼티 추가

```kotlin
@Service
internal class PointWalletService(
    private val userPort: UserPort,
    private val pointWalletPort: PointWalletPort,
    private val pointTransactionPort: PointTransactionPort,
    private val transactional: Transactional
) {
    private val logger: Logger = Log.getLogger(PointWalletService::class.java)

    companion object {
        const val MAX_RETRIES = 10
        const val BACKOFF_MILLIS = 50L
    }

    fun chargePoint(
        userId: UUID,
        amount: Long
    ): Long =
        Log.logging(logger) { log ->
            log["method"] = "chargePoint()"
            verifyUser(userId)

            repeat(MAX_RETRIES) { attempt ->
                try {
                    val chargedWallet: PointWallet =
                        transactional.run {
                            val foundWallet: PointWallet =
                                pointWalletPort.getWallet(userId)
                                    ?: throw PointWalletException(
                                        ErrorCode.NOT_FOUND_USER_POINT_WALLET
                                    )

                            val charged: PointWallet = foundWallet.chargePoint(amount)

                            pointWalletPort.update(charged)

                            pointTransactionPort.save(
                                PointTransaction(
                                    pointWalletId = charged.id,
                                    amount = amount,
                                    type = PointTransaction.Type.CHARGED
                                )
                            )
                            charged
                        }
                    return@logging chargedWallet.balance
                } catch (_: ObjectOptimisticLockingFailureException) {
                    log["retry_attempt"] = attempt + 1
                    Thread.sleep(BACKOFF_MILLIS)
                }
            }
            throw PointWalletException(ErrorCode.FAILED_RETRY, "chargePoint() retry fail")
        }
}
```

- 서비스 로직 또한 경합 발생 시 낙관적 락 예외를 캐치하고, 포인트 충전을 재시도 하는 로직을 추가

### 3️⃣ 좌석 예약

#### 🚨문제 식별

- 동일한 좌석에 대해 동시에 예약 요청이 발생하는 경우 여러 유저에게 동일한 좌석이 예약 되는 문제 발생

```log
Expecting empty but was: [1L]
```

- 테스트 코드로 중복된 좌석을 체크 했을 때 비어있는 값이 반환되기를 기대 하지만 `1` 번 좌석에 대해 중복 예약이 되어 `1L` 이 반환되고 있는 상황

#### 🔍 분석

```text
# 좌석 예약 로직
콘서트 좌석 조회 -> 콘서트 스케쥴 조회 -> 좌석 점유 확인 -> 좌석 졈유 상태 업데이트 -> 콘서트 좌석 상태 업데이트 -> 결제 정보 생성 -> 예약 생성
```

#### 🟢 해결 방안

- 콘서트 좌석을 동시에 조회 한 후 예약하는게 문제가 되는 부분이기 때문에 콘서트 좌석 조회 쪽에 락을 설정하면 될것 같다.

##### 🔐 락

###### ✅ 낙관적 락 (Optimistic Lock)

- [x] 데이터에 **동시에 접근해 수정하는 빈도가 낮다**
- [ ] 충돌이 발생해도 **재시도하는 비용이 낮거나 허용된다**

###### 🔒 비관적 락 (Pessimistic Lock)

- [ ] 동시에 동일 데이터를 수정할 가능성이 **높다**
- [ ] 데이터 충돌 발생 시 **재시도나 롤백이 복잡하거나 위험하다**

- 최초 요청 이후 요청에 대해서는 전부 실패 처리를 하면 되는데, 비관적 락을 사용하는 경우 불필요한 데이터베이스 락이 발생하기 때문에 낙관적 락을 이용해서 동시성 이슈를 해결하면 될것 같다.

#### 🥕 해결

```kotlin
@Entity
@Table(name = "concert_seats")
internal class ConcertSeatEntity(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(nullable = false)
    val scheduleId: Long,
    @Column(nullable = false)
    val seatId: Long,
    @Column(nullable = false)
    @Enumerated(EnumType.STRING)
    val status: Status,
) : BaseEntity() {
    enum class Status {
        HELD,
        AVAILABLE,
        RESERVED
    }
}
```

- 별도의 버전 처리가 되고 있는 않는 모습

```kotlin
@Entity
@Table(name = "concert_seats")
internal class ConcertSeatEntity(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(nullable = false)
    val scheduleId: Long,
    @Column(nullable = false)
    val seatId: Long,
    @Column(nullable = false)
    @Enumerated(EnumType.STRING)
    val status: Status,
    @jakarta.persistence.Version
    @Column(nullable = false)
    var version: Version
) : BaseEntity() {
    enum class Status {
        HELD,
        AVAILABLE,
        RESERVED
    }
}
```

- 낙관적 락을 사용하기 위해 버전 프로퍼티 추가

```kotlin
@Service
internal class ReservationService(
    private val seatHoldPort: SeatHoldPort,
    private val concertSeatPort: ConcertSeatPort,
    private val reservationPort: ReservationPort,
    private val paymentPort: PaymentPort,
    private val reservationContextLoader: ReservationContextLoader,
    private val transactional: Transactional
) {
    private val logger: Logger = Log.getLogger(ReservationService::class.java)

    fun makeReservation(
        date: LocalDate,
        concertSeatId: Long,
        userId: String
    ): MakeReservationResponse =
        Log.logging(logger) { log ->
            log["method"] = "makeReservation()"

            val userUUID: UUID = UUID.fromString(userId)
            try {
                transactional.run {
                    val context: ReservationContext =
                        reservationContextLoader.load(concertSeatId, date)

                    val heldSeat: ConcertSeat = context.concertSeat.held()

                    concertSeatPort.update(heldSeat)

                    seatHoldPort.save(
                        SeatHold(
                            concertSeatId = concertSeatId,
                            userId = userUUID
                        )
                    )
                    
                    // ...
                }
            } catch (_: ObjectOptimisticLockingFailureException) {
                log["concurrency"] = concertSeatId
                throw ConcertSeatException(ErrorCode.OPTIMISTIC_LOCKING_FAILURE)
            }
       }
}
```

- 락 프로퍼티 추가 후 콘서트 좌석을 조회 하는 로직에 충돌 발생 시 해당 요청은 실패 하도록 예외 처리 로직 추가

#### 🔄 Redis 분산 락으로 전환

- DB 낙관적 락을 사용하던 기존 로직에서 Redis 분산 락을 사용하도록 변경

##### 분산 락으로 전환 하는 이유

1. 예약 생성 로직 안에서 여러 도메인이 여러 단계에 걸쳐 생성 되거나, 수정되고 있기 때문에 (예약, 결제, 좌석)
2. 복잡한 트랜젝션을 단순하게 처리 할 수 있기 때문에
3. DB 부하 감소, 대기열의 크기가 커질 수록 발생할 수 있는 경합 발생률이 높아질 수 있고, 그만큼 DB 에 부하가 많이 발생할 수 있기 때문에

#### 구현

- 편리하게 분산 락을 적용시킬 수 있도록 AOP 를 활용

```kotlin
@Aspect
@Component
internal class RedisLocksAspect(
    private val redisson: RedissonClient,
    private val parser: SpelExpressionParser,
    private val parameterNameDiscoverer: DefaultParameterNameDiscoverer
) {
    private val logger: Logger = Log.getLogger(RedisLocksAspect::class.java)

    companion object {
        private const val PREFIX = "lock:"
    }

    @Around("@annotation(redisLocks)")
    fun redisLocks(
        joinPoint: ProceedingJoinPoint,
        redisLocks: RedisLocks
    ): Any? =
        Log.logging(logger) { log ->
            log["method"] = "redisLocks()"
            val method: Method = (joinPoint.signature as MethodSignature).method
            log["joinPoint"] = method.name
            val context =
                MethodBasedEvaluationContext(
                    joinPoint.target,
                    method,
                    joinPoint.args,
                    parameterNameDiscoverer
                )

            val keys: List<String> = resolveAndNormalizeKeys(redisLocks, context)
            val lock: RLock = createLock(keys, redisLocks.useMultiLock)

            if (!tryAcquire(lock, redisLocks.waitSeconds, redisLocks.leaseSeconds)) {
                log["lock.keys"] = keys
                if (redisLocks.waitSeconds == 0L) {
                    throw LockAcquisition(message = "keys: $keys")
                }
                throw RedisLockTimeoutException(message = "keys: $keys")
            }

            try {
                joinPoint.proceed()
            } finally {
                unlockSafely(lock)
            }
        }

    private fun resolveAndNormalizeKeys(
        redisLocks: RedisLocks,
        context: MethodBasedEvaluationContext
    ): List<String> {
        val raw: Set<String> =
            redisLocks.keys
                .flatMap { expression ->
                    when (val value = parser.parseExpression(expression).getValue(context)) {
                        null -> emptyList()
                        is String -> listOf(value)
                        is Collection<*> ->
                            value.map {
                                it?.toString() ?: throw SpelException(
                                    code = ErrorCode.NOT_VALUE_IN_EXPRESSION,
                                    message = expression
                                )
                            }

                        else -> throw SpelException(
                            code = ErrorCode.INVALID_RETURN_TYPE,
                            message = "$value"
                        )
                    }
                }.map { it.trim() }
                .filter { it.isNotEmpty() }
                .toSet()

        if (raw.isEmpty()) {
            throw RedissonException(code = ErrorCode.KEYS_IS_EMPTY)
        }
        val normalized: List<String> = raw.map { if (it.startsWith(PREFIX)) it else "$PREFIX$it" }
        return if (redisLocks.sortKeys) normalized.sorted() else normalized
    }

    private fun createLock(
        keys: List<String>,
        useMultiLock: Boolean
    ): RLock =
        if (useMultiLock && keys.size > 1) {
            val locks: Array<RLock> = keys.map { redisson.getLock(it) }.toTypedArray()
            redisson.getMultiLock(*locks)
        } else {
            redisson.getLock(keys.first())
        }

    private fun tryAcquire(
        lock: RLock,
        waitSeconds: Long,
        leaseSeconds: Long
    ): Boolean =
        if (leaseSeconds == 0L) {
            lock.tryLock(waitSeconds, TimeUnit.SECONDS)
        } else {
            lock.tryLock(waitSeconds, leaseSeconds, TimeUnit.SECONDS)
        }

    private fun unlockSafely(lock: RLock) {
        if (lock.isHeldByCurrentThread) {
            runCatching { lock.unlock() }
                .onFailure {
                    throw RedissonException(
                        code = ErrorCode.FAILED_TO_UNLOCK,
                        message = "lock: ${lock.name}"
                    )
                }
        }
    }
}
```

- SpEL(Spring Expression Language) 를 활용하여, 메서드의 파라미터 이름과 값을 가지고 키 값으로 활용

```kotlin
// RedisLocks 어노테이션
@Target(AnnotationTarget.FUNCTION)
@Retention(AnnotationRetention.RUNTIME)
annotation class RedisLocks(
    val keys: Array<String>,            // 키 목록
    val waitSeconds: Long = 2,          // 락 대기 시간
    val leaseSeconds: Long = 0,         // 락 유지 시간 (0인 경우 와치독 활성화)
    val sortKeys: Boolean = false,      // 키 정렬 (데드락 방지)
    val useMultiLock: Boolean = false   // 멀티 락 유무
)

// Reservation Service 에서 사용
@RedisLocks(
    keys = ["'concertSeat:' + #concertSeatId"],
    waitSeconds = 0,
    leaseSeconds = 3 
)
fun makeReservation()
```

- 최초 요청 이후 요청은 실패하도록, waitSeconds 를 0으로 지정 

### 4️⃣ 예약 결제

#### 🚨문제 식별

- 동시에 결제 요청 시 하나의 예약에 중복 결제가 발생할 것으로 예상

#### 🔍 분석

```text
# 예약 결제 로직
예약 내역 조회 -> 결제 목록 조회 -> 포인트 차감 -> 포인트 업데이트 -> 포인트 내역 추가 -> 결제 상태 업데이트 -> 예약 상태 업데이트 -> 콘서트 좌석 상태 업데이트 -> 좌석 점유 제거 -> 대기열 토큰 상태 업데이트
```

- 포인트 업데이트에서 이전에 설정한 락으로 인해 중복 결제는 되고 있지 않다.
- 다만, 결제쪽에 동시성 예외에 대한 예외 처리 로직이 없어 500 에러 발생으로 부적합한 결제 처리 응답 메세지가 발생하는 상황
- 예약, 결제에 따른 동시성 문제를 포인트 쪽에서 동시성 처리로 인해 해결하고 넘어가는게 맞는걸까?? 이 부분에 대해서는 고민이 필요할것 같다.
  - 포인트로만 동시성이 해결되었다고 넘어가기는 부적절한것 같다. 예외 책임을 넘기는것 같기도 하고, 포인트로 넘어가기 전에 동시성 문제를 발견하고 처리하는게 좋은 방향인것 같다.

##### 🔐 락

###### ✅ 낙관적 락 (Optimistic Lock)

- [x] 데이터에 **동시에 접근해 수정하는 빈도가 낮다**
- [ ] 충돌이 발생해도 **재시도하는 비용이 낮거나 허용된다**

###### 🔒 비관적 락 (Pessimistic Lock)

- [ ] 동시에 동일 데이터를 수정할 가능성이 **높다**
- [ ] 데이터 충돌 발생 시 **재시도나 롤백이 복잡하거나 위험하다**

- 최초 요청 이후 요청에 대해서는 전부 실패 처리를 하면 되는데, 비관적 락을 사용하는 경우 불필요한 데이터베이스 락이 발생하기 때문에 낙관적 락을 이용해서 동시성 이슈를 해결하면 될것 같다.

#### 🟢 해결 방안

- 결제, 예약에 낙관적 락을 적용시켜 중복 결제 처리가 되지 않도록 그리고 결제, 예약 쪽에서 동시성 문제를 해결할 있도록 적용 시키는 방향으로 해야할것 같다.

#### 🥕 해결

- 예약과 결제쪽에 버전 프로퍼티를 추가하여 낙관적 락을 적용 시키고 동시성 문제 발생 시 최초 요청에만 결제 처리가 되고 나머지 요청에는 실패하도록 예외 처리 로직 추가
