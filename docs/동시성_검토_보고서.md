## 📜 동시성 검토 보고서

### ⚙️ 환경

- RestAssured + CompletableFuture 를 사용한 API 요청 테스트
- 동시 요청 건수: 100건

## 📋 동시성 발생 검토

### 1️⃣ 대기열 토큰 발급

#### 🚨문제 식별

```log
Expected :101
Actual   :36
```

- 동시성 테스트를 통한 테스트 결과 100번의 토큰 생성 요청 이후 다음 순번은 101번이 되어야 하지만, 36번으로 나오고 있는 모습.

#### 🔍 분석

```text
# 대기열 토큰 발급 로직
토큰 생성 요청 -> 이미 발급 된 토큰 유무 확인 -> 토큰 다음 순번 조회 -> 토큰 생성 -> 토큰 저장
```

- 현재 구현되어 있는 대기열 토큰 발급 로직 특성 상, 동시에 대기열 토큰 발급 요청이 있는 경우 `queue_tokens` 테이블의 `queueNumber` 가 동시성 문제가
  발생하여 순차적으로 늘어나지 않는 문제 발생

#### 🟢 해결 방안

- 동시성 문제가 발생하고 있는 부분을 해결해야 하는데, 근본적으로는 현재 대기열 토큰 발급 로직 자체가 조금은 부실한것 같다. 이런식의 토큰 발급과 검증은 설계상 조금은 아쉬운
  부분이 존재하는것 같다.
- 다만, 현재 설계를 변경하기에는 조금 어려운 부분들이 있기 때문에 문제 상황을 빠르게 해결할 수 있는 방법으로 접근해야 할것 같다.

##### 🔐 락

- 현재 토큰 발급 로직 상, 요청하는 모든 인원을 대상으로 토큰을 발급해야 하는데 아래 리스트를 체크하며 어떤 락을 사용할지 결정해야할것 같다.

###### ✅ 낙관적 락 (Optimistic Lock)

- [ ] 데이터에 **동시에 접근해 수정하는 빈도가 낮다**
- [ ] 충돌이 발생해도 **재시도하는 비용이 낮거나 허용된다**
- [ ] 시스템이 **높은 처리량과 응답 속도**를 우선시한다
- [ ] 정합성보다는 **처리량과 사용자 경험**이 더 중요하다
- [ ] 데드락(deadlock)이 절대 발생하지 않도록 해야 한다

###### 🔒 비관적 락 (Pessimistic Lock)

- [x] 동시에 동일 데이터를 수정할 가능성이 **높다**
- [x] 데이터 충돌 발생 시 **재시도나 롤백이 복잡하거나 위험하다**
- [x] 충돌이 발생하면 **사용자나 비즈니스에 직접적인 영향**이 있다.
- [x] 절대적인 데이터 정합성이 요구된다.
- [x] 요청 순서나 트랜잭션 순서를 **엄격하게 보장해야 한다**
- [x] 충돌 발생 시 예외 대신 **대기하도록 설계되어야 한다**


- 체크 리스트 확인 결과 비관적 락을 사용하는게 좋을것 같다.
