## ğŸ“œ ë™ì‹œì„± ê²€í†  ë³´ê³ ì„œ

### âš™ï¸ í™˜ê²½

- RestAssured + CompletableFuture ë¥¼ ì‚¬ìš©í•œ API ìš”ì²­ í…ŒìŠ¤íŠ¸
- ë™ì‹œ ìš”ì²­ ê±´ìˆ˜: 100ê±´

## ğŸ“‹ ë™ì‹œì„± ë°œìƒ ê²€í† 

### 1ï¸âƒ£ ëŒ€ê¸°ì—´ í† í° ë°œê¸‰

#### ğŸš¨ë¬¸ì œ ì‹ë³„

```log
Expected :101
Actual   :36
```

- ë™ì‹œì„± í…ŒìŠ¤íŠ¸ë¥¼ í†µí•œ í…ŒìŠ¤íŠ¸ ê²°ê³¼ 100ë²ˆì˜ í† í° ìƒì„± ìš”ì²­ ì´í›„ ë‹¤ìŒ ìˆœë²ˆì€ 101ë²ˆì´ ë˜ì–´ì•¼ í•˜ì§€ë§Œ, 36ë²ˆìœ¼ë¡œ ë‚˜ì˜¤ê³  ìˆëŠ” ëª¨ìŠµ.

#### ğŸ” ë¶„ì„

```text
# ëŒ€ê¸°ì—´ í† í° ë°œê¸‰ ë¡œì§
í† í° ìƒì„± ìš”ì²­ -> ì´ë¯¸ ë°œê¸‰ ëœ í† í° ìœ ë¬´ í™•ì¸ -> í† í° ë‹¤ìŒ ìˆœë²ˆ ì¡°íšŒ -> í† í° ìƒì„± -> í† í° ì €ì¥
```

- í˜„ì¬ êµ¬í˜„ë˜ì–´ ìˆëŠ” ëŒ€ê¸°ì—´ í† í° ë°œê¸‰ ë¡œì§ íŠ¹ì„± ìƒ, ë™ì‹œì— ëŒ€ê¸°ì—´ í† í° ë°œê¸‰ ìš”ì²­ì´ ìˆëŠ” ê²½ìš° `queue_tokens` í…Œì´ë¸”ì˜ `queueNumber` ê°€ ë™ì‹œì„± ë¬¸ì œê°€
  ë°œìƒí•˜ì—¬ ìˆœì°¨ì ìœ¼ë¡œ ëŠ˜ì–´ë‚˜ì§€ ì•ŠëŠ” ë¬¸ì œ ë°œìƒ

#### ğŸŸ¢ í•´ê²° ë°©ì•ˆ

- ë™ì‹œì„± ë¬¸ì œê°€ ë°œìƒí•˜ê³  ìˆëŠ” ë¶€ë¶„ì„ í•´ê²°í•´ì•¼ í•˜ëŠ”ë°, ê·¼ë³¸ì ìœ¼ë¡œëŠ” í˜„ì¬ ëŒ€ê¸°ì—´ í† í° ë°œê¸‰ ë¡œì§ ìì²´ê°€ ì¡°ê¸ˆì€ ë¶€ì‹¤í•œê²ƒ ê°™ë‹¤. ì´ëŸ°ì‹ì˜ í† í° ë°œê¸‰ê³¼ ê²€ì¦ì€ ì„¤ê³„ìƒ ì¡°ê¸ˆì€ ì•„ì‰¬ìš´
  ë¶€ë¶„ì´ ì¡´ì¬í•˜ëŠ”ê²ƒ ê°™ë‹¤.
- ë‹¤ë§Œ, í˜„ì¬ ì„¤ê³„ë¥¼ ë³€ê²½í•˜ê¸°ì—ëŠ” ì¡°ê¸ˆ ì–´ë ¤ìš´ ë¶€ë¶„ë“¤ì´ ìˆê¸° ë•Œë¬¸ì— ë¬¸ì œ ìƒí™©ì„ ë¹ ë¥´ê²Œ í•´ê²°í•  ìˆ˜ ìˆëŠ” ë°©ë²•ìœ¼ë¡œ ì ‘ê·¼í•´ì•¼ í• ê²ƒ ê°™ë‹¤.

##### ğŸ” ë½

- í˜„ì¬ í† í° ë°œê¸‰ ë¡œì§ ìƒ, ìš”ì²­í•˜ëŠ” ëª¨ë“  ì¸ì›ì„ ëŒ€ìƒìœ¼ë¡œ í† í°ì„ ë°œê¸‰í•´ì•¼ í•˜ëŠ”ë° ì•„ë˜ ë¦¬ìŠ¤íŠ¸ë¥¼ ì²´í¬í•˜ë©° ì–´ë–¤ ë½ì„ ì‚¬ìš©í• ì§€ ê²°ì •í•´ì•¼í• ê²ƒ ê°™ë‹¤.

###### âœ… ë‚™ê´€ì  ë½ (Optimistic Lock)

- [ ] ë°ì´í„°ì— **ë™ì‹œì— ì ‘ê·¼í•´ ìˆ˜ì •í•˜ëŠ” ë¹ˆë„ê°€ ë‚®ë‹¤**
- [ ] ì¶©ëŒì´ ë°œìƒí•´ë„ **ì¬ì‹œë„í•˜ëŠ” ë¹„ìš©ì´ ë‚®ê±°ë‚˜ í—ˆìš©ëœë‹¤**
- [ ] ì‹œìŠ¤í…œì´ **ë†’ì€ ì²˜ë¦¬ëŸ‰ê³¼ ì‘ë‹µ ì†ë„**ë¥¼ ìš°ì„ ì‹œí•œë‹¤
- [ ] ì •í•©ì„±ë³´ë‹¤ëŠ” **ì²˜ë¦¬ëŸ‰ê³¼ ì‚¬ìš©ì ê²½í—˜**ì´ ë” ì¤‘ìš”í•˜ë‹¤
- [ ] ë°ë“œë½(deadlock)ì´ ì ˆëŒ€ ë°œìƒí•˜ì§€ ì•Šë„ë¡ í•´ì•¼ í•œë‹¤

###### ğŸ”’ ë¹„ê´€ì  ë½ (Pessimistic Lock)

- [x] ë™ì‹œì— ë™ì¼ ë°ì´í„°ë¥¼ ìˆ˜ì •í•  ê°€ëŠ¥ì„±ì´ **ë†’ë‹¤**
- [x] ë°ì´í„° ì¶©ëŒ ë°œìƒ ì‹œ **ì¬ì‹œë„ë‚˜ ë¡¤ë°±ì´ ë³µì¡í•˜ê±°ë‚˜ ìœ„í—˜í•˜ë‹¤**
- [x] ì¶©ëŒì´ ë°œìƒí•˜ë©´ **ì‚¬ìš©ìë‚˜ ë¹„ì¦ˆë‹ˆìŠ¤ì— ì§ì ‘ì ì¸ ì˜í–¥**ì´ ìˆë‹¤.
- [x] ì ˆëŒ€ì ì¸ ë°ì´í„° ì •í•©ì„±ì´ ìš”êµ¬ëœë‹¤.
- [x] ìš”ì²­ ìˆœì„œë‚˜ íŠ¸ëœì­ì…˜ ìˆœì„œë¥¼ **ì—„ê²©í•˜ê²Œ ë³´ì¥í•´ì•¼ í•œë‹¤**
- [x] ì¶©ëŒ ë°œìƒ ì‹œ ì˜ˆì™¸ ëŒ€ì‹  **ëŒ€ê¸°í•˜ë„ë¡ ì„¤ê³„ë˜ì–´ì•¼ í•œë‹¤**


- ì²´í¬ ë¦¬ìŠ¤íŠ¸ í™•ì¸ ê²°ê³¼ ë¹„ê´€ì  ë½ì„ ì‚¬ìš©í•˜ëŠ”ê²Œ ì¢‹ì„ê²ƒ ê°™ë‹¤.

#### ğŸ¥• í•´ê²°
```kotlin
@Transactional
fun createEntryQueueToken(userId: UUID): String =
    Log.logging(logger) { log ->
        log["method"] = "createEntryQueueToken()"
        if (entryQueuePort.existsWaitingQueueToken(userId)) {
            throw QueueTokenException(ErrorCode.TOKEN_ALREADY_ISSUED, userId.toString())
        }
        val queueNumber: Int = entryQueuePort.getEntryQueueNextNumber()
        val entryQueueToken: String = jwtHelper.createJWT(userId, queueNumber)
        val queueToken =
            QueueToken(
                userId = userId,
                queueNumber = queueNumber,
                token = entryQueueToken
            )
        entryQueuePort.saveEntryQueueToken(queueToken)
        entryQueueToken
    }

@Query(
    value = """
            SELECT COALESCE(MAX(queue_number), 0) + 1
            FROM queue_tokens
        """,
    nativeQuery = true
)
fun findEntryQueueNextNumber(): Int
```
- í˜„ì¬ `Token` ë°œê¸‰ ë¡œì§ ìƒ `Lock`ì„ ì„¤ì •í•˜ê¸° ë§¤ìš° ì–´ë ¤ìš´ ìƒí™©, `getEntryQueueNextNumber()` ë©”ì„œë“œê°€ `SELECT COALESCE(MAX(queue_number), 0) + 1` ì¿¼ë¦¬ë¥¼ ì‚¬ìš©í•˜ëŠ”ë°  
í•´ë‹¹ ì¿¼ë¦¬ì˜ ê²½ìš°ëŠ” `Lock` ì„ ì„¤ì •í•  `Row` ê°€ ì¡´ì¬í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— `Table` ì „ì²´ì— `Lock` ì„ ì„¤ì •í•˜ê²Œ ë˜ëŠ”ë° ë™ì‹œ ìš”ì²­ì´ ë“¤ì–´ì˜¤ëŠ” ê²½ìš° í…Œì´ë¸” ì „ì²´ì— ì„¤ì •í•œ `Lock` ë•Œë¬¸ì— `DeadLock` ì´ ë°œìƒ  
ê²°êµ­ `QueueNumber` ë¥¼ ë³„ë„ë¡œ ì €ì¥í•˜ëŠ” í…Œì´ë¸”ì„ ë§Œë“¤ì–´ì„œ í•´ë‹¹ í…Œì´ë¸”ì˜ `Row` ì— `Lock` ì„ ê±¸ì–´ ë™ì‹œì„± ë¬¸ì œë¥¼ í•´ê²°
- ë™ì‹œì„±ì— ëŒ€í•œ ê²½í—˜ì´ ë¶€ì¡±í•˜ì—¬ ë°œìƒí•œ ë¬¸ì œë¡œ, ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„ ë¶€í„° êµ¬í˜„ ê¹Œì§€ ë™ì‹œì„±ì„ ê³ ë ¤í•˜ì§€ ì•Šê³  ì‘ì—… í–ˆê¸° ë•Œë¬¸ì— ì´ëŸ° ë¬¸ì œê°€ ë°œìƒ.
- `Redis`, `MQ` ë“±ì„ ì‚¬ìš©í–ˆë‹¤ë©´, ì¢€ ë” ì‰½ê²Œ í•´ê²°ì´ ë˜ì—ˆì„ê²ƒ ê°™ì§€ë§Œ ì§€ê¸ˆ ì£¼ì°¨ì—ì„œëŠ” `RDB` ë§Œ ì‚¬ìš©í•´ì•¼ í•˜ê¸°ë„ í•˜ê³ , ì–´ë–»ê²Œë“  í•´ê²°ì„ í•´ë³´ê³  ì‹¶ì–´ ë‹¤ì–‘í•œ ë°©ë²•ì„ ì‹œë„í•˜ë‹¤. í•´ë‹¹ ë°©ë²•ì„ í†µí•´ ë¬¸ì œ í•´ê²°

```kotlin
fun createEntryQueueToken(userId: UUID): String =
    Log.logging(logger) { log ->
        log["method"] = "createEntryQueueToken()"
        if (entryQueuePort.existsWaitingQueueToken(userId)) {
            throw QueueTokenException(ErrorCode.TOKEN_ALREADY_ISSUED, userId.toString())
        }
        transactional.run {
            val queueNumber: Int =
                entryQueuePort.getQueueNumberByIdForUpdate(NUMBER_ID)
            val entryQueueToken: String = jwtHelper.createJWT(userId, queueNumber)
            val queueToken =
                QueueToken(
                    userId = userId,
                    queueNumber = queueNumber,
                    token = entryQueueToken
                )
            entryQueuePort.saveEntryQueueToken(queueToken)
            entryQueuePort.incrementNextNumber(queueNumber + 1)
            entryQueueToken
        }
    }

internal interface EntryQueueNumberJpaRepository : JpaRepository<QueueNumberEntity, String> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT q FROM QueueNumberEntity q WHERE q.id = :id")
    fun findByIdForUpdate(
        @Param("id") id: String
    ): QueueNumberEntity?
}
```

- ë™ì‹œì„± ë¬¸ì œë¥¼ í•´ê²°í•œ ì½”ë“œ, `getQueueNumberByIdForUpdate()` ë©”ì„œë“œë¥¼ í†µí•´ ë¹„ê´€ì  ë½ ì´ ì„¤ì •ë˜ì–´ ìˆëŠ” `QueueNumbers` í…Œì´ë¸”ì—ì„œ `QueueNumber`ë¥¼ ì¡°íšŒ í›„  
í•´ë‹¹ ê°’ìœ¼ë¡œ `Token` ì„ ë°œê¸‰í•˜ê³  ì €ì¥í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ìˆ˜ì •

### 2ï¸âƒ£ í¬ì¸íŠ¸ ì¶©ì „

#### ğŸš¨ë¬¸ì œ ì‹ë³„

```log
expected: 100000L
 but was: 48000L
```

- ë™ì‹œì„± í…ŒìŠ¤íŠ¸ë¥¼ í†µí•´ 100 ê±´ì˜ 1000 í¬ì¸íŠ¸ ì¶©ì „ ìš”ì²­ ì‹œ 100,000 í¬ì¸íŠ¸ê°€ ìµœì¢… ë³´ìœ  í¬ì¸íŠ¸ê°€ ë˜ì–´ì•¼ í•˜ì§€ë§Œ, 48,000 í¬ì¸íŠ¸ë§Œ ë³´ìœ í•˜ê³  ìˆëŠ” ëª¨ìŠµ
- ë‹¹ì—°í•˜ê²Œë„, ë‚´ì—­ì˜ ê²½ìš°ëŠ” 100 ê±´ ëª¨ë‘ ë¬¸ì œ ì—†ì´ ì €ì¥ë˜ëŠ” ì¤‘

#### ğŸ” ë¶„ì„

```text
# í¬ì¸íŠ¸ ì¶©ì „ ë¡œì§
í¬ì¸íŠ¸ ì§€ê°‘ ì¡°íšŒ -> í¬ì¸íŠ¸ ì¶©ì „ -> í¬ì¸íŠ¸ ì§€ê°‘ ì—…ë°ì´íŠ¸ -> í¬ì¸íŠ¸ ë‚´ì—­ ì €ì¥ 
```

- í¬ì¸íŠ¸ ì§€ê°‘ ì¡°íšŒ -> í¬ì¸íŠ¸ ì¶©ì „ ì‚¬ì´ì—ì„œ ë™ì‹œì„± ë¬¸ì œê°€ ë°œìƒí•˜ê³  ìˆëŠ”ê²ƒìœ¼ë¡œ íŒë‹¨

#### ğŸŸ¢ í•´ê²° ë°©ì•ˆ

- í¬ì¸íŠ¸ ì§€ê°‘ ì¡°íšŒì— ë½ì„ ì„¤ì •í•˜ì—¬ ë™ì‹œì— ì¡°íšŒ í›„ ì—…ë°ì´íŠ¸ í•˜ëŠ” ë¬¸ì œë¥¼ ë°©ì§€í•˜ë©´ í•´ê²°ì´ ë ê²ƒ ê°™ë‹¤.

##### ğŸ” ë½

- ì•„ë˜ ì²´í¬ ë¦¬ìŠ¤íŠ¸ë¥¼ í†µí•´ ì–´ë–¤ ë½ì„ ì‚¬ìš©í• ì§€ ê²°ì •í•´ì•¼ í• ê²ƒ ê°™ë‹¤.  

###### âœ… ë‚™ê´€ì  ë½ (Optimistic Lock)

- [x] ë°ì´í„°ì— **ë™ì‹œì— ì ‘ê·¼í•´ ìˆ˜ì •í•˜ëŠ” ë¹ˆë„ê°€ ë‚®ë‹¤**
- [x] ì¶©ëŒì´ ë°œìƒí•´ë„ **ì¬ì‹œë„í•˜ëŠ” ë¹„ìš©ì´ ë‚®ê±°ë‚˜ í—ˆìš©ëœë‹¤**
- [ ] ì‹œìŠ¤í…œì´ **ë†’ì€ ì²˜ë¦¬ëŸ‰ê³¼ ì‘ë‹µ ì†ë„**ë¥¼ ìš°ì„ ì‹œí•œë‹¤
- [ ] ì •í•©ì„±ë³´ë‹¤ëŠ” **ì²˜ë¦¬ëŸ‰ê³¼ ì‚¬ìš©ì ê²½í—˜**ì´ ë” ì¤‘ìš”í•˜ë‹¤
- [ ] ë°ë“œë½(deadlock)ì´ ì ˆëŒ€ ë°œìƒí•˜ì§€ ì•Šë„ë¡ í•´ì•¼ í•œë‹¤

###### ğŸ”’ ë¹„ê´€ì  ë½ (Pessimistic Lock)

- [ ] ë™ì‹œì— ë™ì¼ ë°ì´í„°ë¥¼ ìˆ˜ì •í•  ê°€ëŠ¥ì„±ì´ **ë†’ë‹¤**
- [ ] ë°ì´í„° ì¶©ëŒ ë°œìƒ ì‹œ **ì¬ì‹œë„ë‚˜ ë¡¤ë°±ì´ ë³µì¡í•˜ê±°ë‚˜ ìœ„í—˜í•˜ë‹¤**
- [x] ì¶©ëŒì´ ë°œìƒí•˜ë©´ **ì‚¬ìš©ìë‚˜ ë¹„ì¦ˆë‹ˆìŠ¤ì— ì§ì ‘ì ì¸ ì˜í–¥**ì´ ìˆë‹¤.
- [ ] ì ˆëŒ€ì ì¸ ë°ì´í„° ì •í•©ì„±ì´ ìš”êµ¬ëœë‹¤.
- [ ] ìš”ì²­ ìˆœì„œë‚˜ íŠ¸ëœì­ì…˜ ìˆœì„œë¥¼ **ì—„ê²©í•˜ê²Œ ë³´ì¥í•´ì•¼ í•œë‹¤**
- [ ] ì¶©ëŒ ë°œìƒ ì‹œ ì˜ˆì™¸ ëŒ€ì‹  **ëŒ€ê¸°í•˜ë„ë¡ ì„¤ê³„ë˜ì–´ì•¼ í•œë‹¤**

- í¬ì¸íŠ¸ ì¶©ì „ì˜ ì¬ì‹œë„ ê´€ì ì—ì„œ ë‚™ê´€ì  ë½ì„ ì‚¬ìš©í•˜ëŠ”ê²Œ ì¢‹ì„ê²ƒ ê°™ë‹¤.

#### ğŸ¥• í•´ê²°

```kotlin
@Entity
@Table(name = "point_wallets")
internal class PointWalletEntity(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(nullable = false, length = 36)
    val userId: String,
    @Column(nullable = false)
    val balance: Long,
) : BaseEntity()
```

- ê¸°ì¡´ì—ëŠ” ë³„ë„ì˜ ë²„ì „ ê´€ë¦¬ë¥¼ ìœ„í•œ í”„ë¡œí¼í‹°ê°€ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ëª¨ìŠµ.

```kotlin
@Entity
@Table(name = "point_wallets")
internal class PointWalletEntity(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(nullable = false, length = 36)
    val userId: String,
    @Column(nullable = false)
    val balance: Long,
    @jakarta.persistence.Version
    @Column(nullable = false)
    var version: Version = Version(0)
) : BaseEntity()
```

- ë‚™ê´€ì  ë½ì„ ì‚¬ìš©í•˜ê¸° ìœ„í•´ `version` í”„ë¡œí¼í‹° ì¶”ê°€

```kotlin
@Service
internal class PointWalletService(
    private val userPort: UserPort,
    private val pointWalletPort: PointWalletPort,
    private val pointTransactionPort: PointTransactionPort,
    private val transactional: Transactional
) {
    private val logger: Logger = Log.getLogger(PointWalletService::class.java)

    companion object {
        const val MAX_RETRIES = 10
        const val BACKOFF_MILLIS = 50L
    }

    fun chargePoint(
        userId: UUID,
        amount: Long
    ): Long =
        Log.logging(logger) { log ->
            log["method"] = "chargePoint()"
            verifyUser(userId)

            repeat(MAX_RETRIES) { attempt ->
                try {
                    val chargedWallet: PointWallet =
                        transactional.run {
                            val foundWallet: PointWallet =
                                pointWalletPort.getWallet(userId)
                                    ?: throw PointWalletException(
                                        ErrorCode.NOT_FOUND_USER_POINT_WALLET
                                    )

                            val charged: PointWallet = foundWallet.chargePoint(amount)

                            pointWalletPort.update(charged)

                            pointTransactionPort.save(
                                PointTransaction(
                                    pointWalletId = charged.id,
                                    amount = amount,
                                    type = PointTransaction.Type.CHARGED
                                )
                            )
                            charged
                        }
                    return@logging chargedWallet.balance
                } catch (_: ObjectOptimisticLockingFailureException) {
                    log["retry_attempt"] = attempt + 1
                    Thread.sleep(BACKOFF_MILLIS)
                }
            }
            throw PointWalletException(ErrorCode.FAILED_RETRY, "chargePoint() retry fail")
        }
}
```

- ì„œë¹„ìŠ¤ ë¡œì§ ë˜í•œ ê²½í•© ë°œìƒ ì‹œ ë‚™ê´€ì  ë½ ì˜ˆì™¸ë¥¼ ìºì¹˜í•˜ê³ , í¬ì¸íŠ¸ ì¶©ì „ì„ ì¬ì‹œë„ í•˜ëŠ” ë¡œì§ì„ ì¶”ê°€

### 3ï¸âƒ£ ì¢Œì„ ì˜ˆì•½

#### ğŸš¨ë¬¸ì œ ì‹ë³„

- ë™ì¼í•œ ì¢Œì„ì— ëŒ€í•´ ë™ì‹œì— ì˜ˆì•½ ìš”ì²­ì´ ë°œìƒí•˜ëŠ” ê²½ìš° ì—¬ëŸ¬ ìœ ì €ì—ê²Œ ë™ì¼í•œ ì¢Œì„ì´ ì˜ˆì•½ ë˜ëŠ” ë¬¸ì œ ë°œìƒ

```log
Expecting empty but was: [1L]
```

- í…ŒìŠ¤íŠ¸ ì½”ë“œë¡œ ì¤‘ë³µëœ ì¢Œì„ì„ ì²´í¬ í–ˆì„ ë•Œ ë¹„ì–´ìˆëŠ” ê°’ì´ ë°˜í™˜ë˜ê¸°ë¥¼ ê¸°ëŒ€ í•˜ì§€ë§Œ `1` ë²ˆ ì¢Œì„ì— ëŒ€í•´ ì¤‘ë³µ ì˜ˆì•½ì´ ë˜ì–´ `1L` ì´ ë°˜í™˜ë˜ê³  ìˆëŠ” ìƒí™©

#### ğŸ” ë¶„ì„

```text
# ì¢Œì„ ì˜ˆì•½ ë¡œì§
ì½˜ì„œíŠ¸ ì¢Œì„ ì¡°íšŒ -> ì½˜ì„œíŠ¸ ìŠ¤ì¼€ì¥´ ì¡°íšŒ -> ì¢Œì„ ì ìœ  í™•ì¸ -> ì¢Œì„ ì¡ˆìœ  ìƒíƒœ ì—…ë°ì´íŠ¸ -> ì½˜ì„œíŠ¸ ì¢Œì„ ìƒíƒœ ì—…ë°ì´íŠ¸ -> ê²°ì œ ì •ë³´ ìƒì„± -> ì˜ˆì•½ ìƒì„±
```

#### ğŸŸ¢ í•´ê²° ë°©ì•ˆ

- ì½˜ì„œíŠ¸ ì¢Œì„ì„ ë™ì‹œì— ì¡°íšŒ í•œ í›„ ì˜ˆì•½í•˜ëŠ”ê²Œ ë¬¸ì œê°€ ë˜ëŠ” ë¶€ë¶„ì´ê¸° ë•Œë¬¸ì— ì½˜ì„œíŠ¸ ì¢Œì„ ì¡°íšŒ ìª½ì— ë½ì„ ì„¤ì •í•˜ë©´ ë ê²ƒ ê°™ë‹¤.

##### ğŸ” ë½

###### âœ… ë‚™ê´€ì  ë½ (Optimistic Lock)

- [x] ë°ì´í„°ì— **ë™ì‹œì— ì ‘ê·¼í•´ ìˆ˜ì •í•˜ëŠ” ë¹ˆë„ê°€ ë‚®ë‹¤**
- [ ] ì¶©ëŒì´ ë°œìƒí•´ë„ **ì¬ì‹œë„í•˜ëŠ” ë¹„ìš©ì´ ë‚®ê±°ë‚˜ í—ˆìš©ëœë‹¤**
- [x] ì‹œìŠ¤í…œì´ **ë†’ì€ ì²˜ë¦¬ëŸ‰ê³¼ ì‘ë‹µ ì†ë„**ë¥¼ ìš°ì„ ì‹œí•œë‹¤
- [x] ì •í•©ì„±ë³´ë‹¤ëŠ” **ì²˜ë¦¬ëŸ‰ê³¼ ì‚¬ìš©ì ê²½í—˜**ì´ ë” ì¤‘ìš”í•˜ë‹¤
- [x] ë°ë“œë½(deadlock)ì´ ì ˆëŒ€ ë°œìƒí•˜ì§€ ì•Šë„ë¡ í•´ì•¼ í•œë‹¤

###### ğŸ”’ ë¹„ê´€ì  ë½ (Pessimistic Lock)

- [ ] ë™ì‹œì— ë™ì¼ ë°ì´í„°ë¥¼ ìˆ˜ì •í•  ê°€ëŠ¥ì„±ì´ **ë†’ë‹¤**
- [ ] ë°ì´í„° ì¶©ëŒ ë°œìƒ ì‹œ **ì¬ì‹œë„ë‚˜ ë¡¤ë°±ì´ ë³µì¡í•˜ê±°ë‚˜ ìœ„í—˜í•˜ë‹¤**
- [ ] ì¶©ëŒì´ ë°œìƒí•˜ë©´ **ì‚¬ìš©ìë‚˜ ë¹„ì¦ˆë‹ˆìŠ¤ì— ì§ì ‘ì ì¸ ì˜í–¥**ì´ ìˆë‹¤.
- [ ] ì ˆëŒ€ì ì¸ ë°ì´í„° ì •í•©ì„±ì´ ìš”êµ¬ëœë‹¤.
- [ ] ìš”ì²­ ìˆœì„œë‚˜ íŠ¸ëœì­ì…˜ ìˆœì„œë¥¼ **ì—„ê²©í•˜ê²Œ ë³´ì¥í•´ì•¼ í•œë‹¤**
- [ ] ì¶©ëŒ ë°œìƒ ì‹œ ì˜ˆì™¸ ëŒ€ì‹  **ëŒ€ê¸°í•˜ë„ë¡ ì„¤ê³„ë˜ì–´ì•¼ í•œë‹¤**

- ìµœì´ˆ ìš”ì²­ ì´í›„ ìš”ì²­ì— ëŒ€í•´ì„œëŠ” ì „ë¶€ ì‹¤íŒ¨ ì²˜ë¦¬ë¥¼ í•˜ë©´ ë˜ëŠ”ë°, ë¹„ê´€ì  ë½ì„ ì‚¬ìš©í•˜ëŠ” ê²½ìš° ë¶ˆí•„ìš”í•œ ë°ì´í„°ë² ì´ìŠ¤ ë½ì´ ë°œìƒí•˜ê¸° ë•Œë¬¸ì— ë‚™ê´€ì  ë½ì„ ì´ìš©í•´ì„œ ë™ì‹œì„± ì´ìŠˆë¥¼ í•´ê²°í•˜ë©´ ë ê²ƒ ê°™ë‹¤.

#### ğŸ¥• í•´ê²°

```kotlin
@Entity
@Table(name = "concert_seats")
internal class ConcertSeatEntity(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(nullable = false)
    val scheduleId: Long,
    @Column(nullable = false)
    val seatId: Long,
    @Column(nullable = false)
    @Enumerated(EnumType.STRING)
    val status: Status,
) : BaseEntity() {
    enum class Status {
        HELD,
        AVAILABLE,
        RESERVED
    }
}
```

- ë³„ë„ì˜ ë²„ì „ ì²˜ë¦¬ê°€ ë˜ê³  ìˆëŠ” ì•ŠëŠ” ëª¨ìŠµ

```kotlin
@Entity
@Table(name = "concert_seats")
internal class ConcertSeatEntity(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(nullable = false)
    val scheduleId: Long,
    @Column(nullable = false)
    val seatId: Long,
    @Column(nullable = false)
    @Enumerated(EnumType.STRING)
    val status: Status,
    @jakarta.persistence.Version
    @Column(nullable = false)
    var version: Version
) : BaseEntity() {
    enum class Status {
        HELD,
        AVAILABLE,
        RESERVED
    }
}
```

- ë‚™ê´€ì  ë½ì„ ì‚¬ìš©í•˜ê¸° ìœ„í•´ ë²„ì „ í”„ë¡œí¼í‹° ì¶”ê°€

```kotlin
@Service
internal class ReservationService(
    private val seatHoldPort: SeatHoldPort,
    private val concertSeatPort: ConcertSeatPort,
    private val reservationPort: ReservationPort,
    private val paymentPort: PaymentPort,
    private val reservationContextLoader: ReservationContextLoader,
    private val transactional: Transactional
) {
    private val logger: Logger = Log.getLogger(ReservationService::class.java)

    fun makeReservation(
        date: LocalDate,
        concertSeatId: Long,
        userId: String
    ): MakeReservationResponse =
        Log.logging(logger) { log ->
            log["method"] = "makeReservation()"

            val userUUID: UUID = UUID.fromString(userId)
            try {
                transactional.run {
                    val context: ReservationContext =
                        reservationContextLoader.load(concertSeatId, date)

                    val heldSeat: ConcertSeat = context.concertSeat.held()

                    concertSeatPort.update(heldSeat)

                    seatHoldPort.save(
                        SeatHold(
                            concertSeatId = concertSeatId,
                            userId = userUUID
                        )
                    )
                    
                    // ...
                }
            } catch (_: ObjectOptimisticLockingFailureException) {
                log["concurrency"] = concertSeatId
                throw ConcertSeatException(ErrorCode.OPTIMISTIC_LOCKING_FAILURE)
            }
       }
}
```

- ë½ í”„ë¡œí¼í‹° ì¶”ê°€ í›„ ì½˜ì„œíŠ¸ ì¢Œì„ì„ ì¡°íšŒ í•˜ëŠ” ë¡œì§ì— ì¶©ëŒ ë°œìƒ ì‹œ í•´ë‹¹ ìš”ì²­ì€ ì‹¤íŒ¨ í•˜ë„ë¡ ì˜ˆì™¸ ì²˜ë¦¬ ë¡œì§ ì¶”ê°€
