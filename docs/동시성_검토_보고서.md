## ğŸ“œ ë™ì‹œì„± ê²€í†  ë³´ê³ ì„œ

### âš™ï¸ í™˜ê²½

- RestAssured + CompletableFuture ë¥¼ ì‚¬ìš©í•œ API ìš”ì²­ í…ŒìŠ¤íŠ¸
- ë™ì‹œ ìš”ì²­ ê±´ìˆ˜: 100ê±´

## ğŸ“‹ ë™ì‹œì„± ë°œìƒ ê²€í† 

### 1ï¸âƒ£ ëŒ€ê¸°ì—´ í† í° ë°œê¸‰

#### ğŸš¨ë¬¸ì œ ì‹ë³„

```log
Expected :101
Actual   :36
```

- ë™ì‹œì„± í…ŒìŠ¤íŠ¸ë¥¼ í†µí•œ í…ŒìŠ¤íŠ¸ ê²°ê³¼ 100ë²ˆì˜ í† í° ìƒì„± ìš”ì²­ ì´í›„ ë‹¤ìŒ ìˆœë²ˆì€ 101ë²ˆì´ ë˜ì–´ì•¼ í•˜ì§€ë§Œ, 36ë²ˆìœ¼ë¡œ ë‚˜ì˜¤ê³  ìˆëŠ” ëª¨ìŠµ.

#### ğŸ” ë¶„ì„

```text
# ëŒ€ê¸°ì—´ í† í° ë°œê¸‰ ë¡œì§
í† í° ìƒì„± ìš”ì²­ -> ì´ë¯¸ ë°œê¸‰ ëœ í† í° ìœ ë¬´ í™•ì¸ -> í† í° ë‹¤ìŒ ìˆœë²ˆ ì¡°íšŒ -> í† í° ìƒì„± -> í† í° ì €ì¥
```

- í˜„ì¬ êµ¬í˜„ë˜ì–´ ìˆëŠ” ëŒ€ê¸°ì—´ í† í° ë°œê¸‰ ë¡œì§ íŠ¹ì„± ìƒ, ë™ì‹œì— ëŒ€ê¸°ì—´ í† í° ë°œê¸‰ ìš”ì²­ì´ ìˆëŠ” ê²½ìš° `queue_tokens` í…Œì´ë¸”ì˜ `queueNumber` ê°€ ë™ì‹œì„± ë¬¸ì œê°€
  ë°œìƒí•˜ì—¬ ìˆœì°¨ì ìœ¼ë¡œ ëŠ˜ì–´ë‚˜ì§€ ì•ŠëŠ” ë¬¸ì œ ë°œìƒ

#### ğŸŸ¢ í•´ê²° ë°©ì•ˆ

- ë™ì‹œì„± ë¬¸ì œê°€ ë°œìƒí•˜ê³  ìˆëŠ” ë¶€ë¶„ì„ í•´ê²°í•´ì•¼ í•˜ëŠ”ë°, ê·¼ë³¸ì ìœ¼ë¡œëŠ” í˜„ì¬ ëŒ€ê¸°ì—´ í† í° ë°œê¸‰ ë¡œì§ ìì²´ê°€ ì¡°ê¸ˆì€ ë¶€ì‹¤í•œê²ƒ ê°™ë‹¤. ì´ëŸ°ì‹ì˜ í† í° ë°œê¸‰ê³¼ ê²€ì¦ì€ ì„¤ê³„ìƒ ì¡°ê¸ˆì€ ì•„ì‰¬ìš´
  ë¶€ë¶„ì´ ì¡´ì¬í•˜ëŠ”ê²ƒ ê°™ë‹¤.
- ë‹¤ë§Œ, í˜„ì¬ ì„¤ê³„ë¥¼ ë³€ê²½í•˜ê¸°ì—ëŠ” ì¡°ê¸ˆ ì–´ë ¤ìš´ ë¶€ë¶„ë“¤ì´ ìˆê¸° ë•Œë¬¸ì— ë¬¸ì œ ìƒí™©ì„ ë¹ ë¥´ê²Œ í•´ê²°í•  ìˆ˜ ìˆëŠ” ë°©ë²•ìœ¼ë¡œ ì ‘ê·¼í•´ì•¼ í• ê²ƒ ê°™ë‹¤.

##### ğŸ” ë½

- í˜„ì¬ í† í° ë°œê¸‰ ë¡œì§ ìƒ, ìš”ì²­í•˜ëŠ” ëª¨ë“  ì¸ì›ì„ ëŒ€ìƒìœ¼ë¡œ í† í°ì„ ë°œê¸‰í•´ì•¼ í•˜ëŠ”ë° ì•„ë˜ ë¦¬ìŠ¤íŠ¸ë¥¼ ì²´í¬í•˜ë©° ì–´ë–¤ ë½ì„ ì‚¬ìš©í• ì§€ ê²°ì •í•´ì•¼í• ê²ƒ ê°™ë‹¤.

###### âœ… ë‚™ê´€ì  ë½ (Optimistic Lock)

- [ ] ë°ì´í„°ì— **ë™ì‹œì— ì ‘ê·¼í•´ ìˆ˜ì •í•˜ëŠ” ë¹ˆë„ê°€ ë‚®ë‹¤**
- [ ] ì¶©ëŒì´ ë°œìƒí•´ë„ **ì¬ì‹œë„í•˜ëŠ” ë¹„ìš©ì´ ë‚®ê±°ë‚˜ í—ˆìš©ëœë‹¤**
- [ ] ì‹œìŠ¤í…œì´ **ë†’ì€ ì²˜ë¦¬ëŸ‰ê³¼ ì‘ë‹µ ì†ë„**ë¥¼ ìš°ì„ ì‹œí•œë‹¤
- [ ] ì •í•©ì„±ë³´ë‹¤ëŠ” **ì²˜ë¦¬ëŸ‰ê³¼ ì‚¬ìš©ì ê²½í—˜**ì´ ë” ì¤‘ìš”í•˜ë‹¤
- [ ] ë°ë“œë½(deadlock)ì´ ì ˆëŒ€ ë°œìƒí•˜ì§€ ì•Šë„ë¡ í•´ì•¼ í•œë‹¤

###### ğŸ”’ ë¹„ê´€ì  ë½ (Pessimistic Lock)

- [x] ë™ì‹œì— ë™ì¼ ë°ì´í„°ë¥¼ ìˆ˜ì •í•  ê°€ëŠ¥ì„±ì´ **ë†’ë‹¤**
- [x] ë°ì´í„° ì¶©ëŒ ë°œìƒ ì‹œ **ì¬ì‹œë„ë‚˜ ë¡¤ë°±ì´ ë³µì¡í•˜ê±°ë‚˜ ìœ„í—˜í•˜ë‹¤**
- [x] ì¶©ëŒì´ ë°œìƒí•˜ë©´ **ì‚¬ìš©ìë‚˜ ë¹„ì¦ˆë‹ˆìŠ¤ì— ì§ì ‘ì ì¸ ì˜í–¥**ì´ ìˆë‹¤.
- [x] ì ˆëŒ€ì ì¸ ë°ì´í„° ì •í•©ì„±ì´ ìš”êµ¬ëœë‹¤.
- [x] ìš”ì²­ ìˆœì„œë‚˜ íŠ¸ëœì­ì…˜ ìˆœì„œë¥¼ **ì—„ê²©í•˜ê²Œ ë³´ì¥í•´ì•¼ í•œë‹¤**
- [x] ì¶©ëŒ ë°œìƒ ì‹œ ì˜ˆì™¸ ëŒ€ì‹  **ëŒ€ê¸°í•˜ë„ë¡ ì„¤ê³„ë˜ì–´ì•¼ í•œë‹¤**


- ì²´í¬ ë¦¬ìŠ¤íŠ¸ í™•ì¸ ê²°ê³¼ ë¹„ê´€ì  ë½ì„ ì‚¬ìš©í•˜ëŠ”ê²Œ ì¢‹ì„ê²ƒ ê°™ë‹¤.

#### ğŸ¥• í•´ê²°
```kotlin
@Transactional
fun createEntryQueueToken(userId: UUID): String =
    Log.logging(logger) { log ->
        log["method"] = "createEntryQueueToken()"
        if (entryQueuePort.existsWaitingQueueToken(userId)) {
            throw QueueTokenException(ErrorCode.TOKEN_ALREADY_ISSUED, userId.toString())
        }
        val queueNumber: Int = entryQueuePort.getEntryQueueNextNumber()
        val entryQueueToken: String = jwtHelper.createJWT(userId, queueNumber)
        val queueToken =
            QueueToken(
                userId = userId,
                queueNumber = queueNumber,
                token = entryQueueToken
            )
        entryQueuePort.saveEntryQueueToken(queueToken)
        entryQueueToken
    }

@Query(
    value = """
            SELECT COALESCE(MAX(queue_number), 0) + 1
            FROM queue_tokens
        """,
    nativeQuery = true
)
fun findEntryQueueNextNumber(): Int
```
- í˜„ì¬ `Token` ë°œê¸‰ ë¡œì§ ìƒ `Lock`ì„ ì„¤ì •í•˜ê¸° ë§¤ìš° ì–´ë ¤ìš´ ìƒí™©, `getEntryQueueNextNumber()` ë©”ì„œë“œê°€ `SELECT COALESCE(MAX(queue_number), 0) + 1` ì¿¼ë¦¬ë¥¼ ì‚¬ìš©í•˜ëŠ”ë°  
í•´ë‹¹ ì¿¼ë¦¬ì˜ ê²½ìš°ëŠ” `Lock` ì„ ì„¤ì •í•  `Row` ê°€ ì¡´ì¬í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— `Table` ì „ì²´ì— `Lock` ì„ ì„¤ì •í•˜ê²Œ ë˜ëŠ”ë° ë™ì‹œ ìš”ì²­ì´ ë“¤ì–´ì˜¤ëŠ” ê²½ìš° í…Œì´ë¸” ì „ì²´ì— ì„¤ì •í•œ `Lock` ë•Œë¬¸ì— `DeadLock` ì´ ë°œìƒ  
ê²°êµ­ `QueueNumber` ë¥¼ ë³„ë„ë¡œ ì €ì¥í•˜ëŠ” í…Œì´ë¸”ì„ ë§Œë“¤ì–´ì„œ í•´ë‹¹ í…Œì´ë¸”ì˜ `Row` ì— `Lock` ì„ ê±¸ì–´ ë™ì‹œì„± ë¬¸ì œë¥¼ í•´ê²°
- ë™ì‹œì„±ì— ëŒ€í•œ ê²½í—˜ì´ ë¶€ì¡±í•˜ì—¬ ë°œìƒí•œ ë¬¸ì œë¡œ, ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„ ë¶€í„° êµ¬í˜„ ê¹Œì§€ ë™ì‹œì„±ì„ ê³ ë ¤í•˜ì§€ ì•Šê³  ì‘ì—… í–ˆê¸° ë•Œë¬¸ì— ì´ëŸ° ë¬¸ì œê°€ ë°œìƒ.
- `Redis`, `MQ` ë“±ì„ ì‚¬ìš©í–ˆë‹¤ë©´, ì¢€ ë” ì‰½ê²Œ í•´ê²°ì´ ë˜ì—ˆì„ê²ƒ ê°™ì§€ë§Œ ì§€ê¸ˆ ì£¼ì°¨ì—ì„œëŠ” `RDB` ë§Œ ì‚¬ìš©í•´ì•¼ í•˜ê¸°ë„ í•˜ê³ , ì–´ë–»ê²Œë“  í•´ê²°ì„ í•´ë³´ê³  ì‹¶ì–´ ë‹¤ì–‘í•œ ë°©ë²•ì„ ì‹œë„í•˜ë‹¤. í•´ë‹¹ ë°©ë²•ì„ í†µí•´ ë¬¸ì œ í•´ê²°

```kotlin
fun createEntryQueueToken(userId: UUID): String =
    Log.logging(logger) { log ->
        log["method"] = "createEntryQueueToken()"
        if (entryQueuePort.existsWaitingQueueToken(userId)) {
            throw QueueTokenException(ErrorCode.TOKEN_ALREADY_ISSUED, userId.toString())
        }
        transactional.run {
            val queueNumber: Int =
                entryQueuePort.getQueueNumberByIdForUpdate(NUMBER_ID)
            val entryQueueToken: String = jwtHelper.createJWT(userId, queueNumber)
            val queueToken =
                QueueToken(
                    userId = userId,
                    queueNumber = queueNumber,
                    token = entryQueueToken
                )
            entryQueuePort.saveEntryQueueToken(queueToken)
            entryQueuePort.incrementNextNumber(queueNumber + 1)
            entryQueueToken
        }
    }

internal interface EntryQueueNumberJpaRepository : JpaRepository<QueueNumberEntity, String> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT q FROM QueueNumberEntity q WHERE q.id = :id")
    fun findByIdForUpdate(
        @Param("id") id: String
    ): QueueNumberEntity?
}
```

- ë™ì‹œì„± ë¬¸ì œë¥¼ í•´ê²°í•œ ì½”ë“œ, `getQueueNumberByIdForUpdate()` ë©”ì„œë“œë¥¼ í†µí•´ ë¹„ê´€ì  ë½ ì´ ì„¤ì •ë˜ì–´ ìˆëŠ” `QueueNumbers` í…Œì´ë¸”ì—ì„œ `QueueNumber`ë¥¼ ì¡°íšŒ í›„  
í•´ë‹¹ ê°’ìœ¼ë¡œ `Token` ì„ ë°œê¸‰í•˜ê³  ì €ì¥í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ìˆ˜ì •
