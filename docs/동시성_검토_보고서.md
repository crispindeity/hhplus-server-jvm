## 📜 동시성 검토 보고서

### ⚙️ 환경

- RestAssured + CompletableFuture 를 사용한 API 요청 테스트
- 동시 요청 건수: 100건

## 📋 동시성 발생 검토

### 1️⃣ 대기열 토큰 발급

#### 🚨문제 식별

```log
Expected :101
Actual   :36
```

- 동시성 테스트를 통한 테스트 결과 100번의 토큰 생성 요청 이후 다음 순번은 101번이 되어야 하지만, 36번으로 나오고 있는 모습.

#### 🔍 분석

```text
# 대기열 토큰 발급 로직
토큰 생성 요청 -> 이미 발급 된 토큰 유무 확인 -> 토큰 다음 순번 조회 -> 토큰 생성 -> 토큰 저장
```

- 현재 구현되어 있는 대기열 토큰 발급 로직 특성 상, 동시에 대기열 토큰 발급 요청이 있는 경우 `queue_tokens` 테이블의 `queueNumber` 가 동시성 문제가
  발생하여 순차적으로 늘어나지 않는 문제 발생

#### 🟢 해결 방안

- 동시성 문제가 발생하고 있는 부분을 해결해야 하는데, 근본적으로는 현재 대기열 토큰 발급 로직 자체가 조금은 부실한것 같다. 이런식의 토큰 발급과 검증은 설계상 조금은 아쉬운
  부분이 존재하는것 같다.
- 다만, 현재 설계를 변경하기에는 조금 어려운 부분들이 있기 때문에 문제 상황을 빠르게 해결할 수 있는 방법으로 접근해야 할것 같다.

##### 🔐 락

- 현재 토큰 발급 로직 상, 요청하는 모든 인원을 대상으로 토큰을 발급해야 하는데 아래 리스트를 체크하며 어떤 락을 사용할지 결정해야할것 같다.

###### ✅ 낙관적 락 (Optimistic Lock)

- [ ] 데이터에 **동시에 접근해 수정하는 빈도가 낮다**
- [ ] 충돌이 발생해도 **재시도하는 비용이 낮거나 허용된다**
- [ ] 시스템이 **높은 처리량과 응답 속도**를 우선시한다
- [ ] 정합성보다는 **처리량과 사용자 경험**이 더 중요하다
- [ ] 데드락(deadlock)이 절대 발생하지 않도록 해야 한다

###### 🔒 비관적 락 (Pessimistic Lock)

- [x] 동시에 동일 데이터를 수정할 가능성이 **높다**
- [x] 데이터 충돌 발생 시 **재시도나 롤백이 복잡하거나 위험하다**
- [x] 충돌이 발생하면 **사용자나 비즈니스에 직접적인 영향**이 있다.
- [x] 절대적인 데이터 정합성이 요구된다.
- [x] 요청 순서나 트랜잭션 순서를 **엄격하게 보장해야 한다**
- [x] 충돌 발생 시 예외 대신 **대기하도록 설계되어야 한다**


- 체크 리스트 확인 결과 비관적 락을 사용하는게 좋을것 같다.

#### 🥕 해결
```kotlin
@Transactional
fun createEntryQueueToken(userId: UUID): String =
    Log.logging(logger) { log ->
        log["method"] = "createEntryQueueToken()"
        if (entryQueuePort.existsWaitingQueueToken(userId)) {
            throw QueueTokenException(ErrorCode.TOKEN_ALREADY_ISSUED, userId.toString())
        }
        val queueNumber: Int = entryQueuePort.getEntryQueueNextNumber()
        val entryQueueToken: String = jwtHelper.createJWT(userId, queueNumber)
        val queueToken =
            QueueToken(
                userId = userId,
                queueNumber = queueNumber,
                token = entryQueueToken
            )
        entryQueuePort.saveEntryQueueToken(queueToken)
        entryQueueToken
    }

@Query(
    value = """
            SELECT COALESCE(MAX(queue_number), 0) + 1
            FROM queue_tokens
        """,
    nativeQuery = true
)
fun findEntryQueueNextNumber(): Int
```
- 현재 `Token` 발급 로직 상 `Lock`을 설정하기 매우 어려운 상황, `getEntryQueueNextNumber()` 메서드가 `SELECT COALESCE(MAX(queue_number), 0) + 1` 쿼리를 사용하는데  
해당 쿼리의 경우는 `Lock` 을 설정할 `Row` 가 존재하지 않기 때문에 `Table` 전체에 `Lock` 을 설정하게 되는데 동시 요청이 들어오는 경우 테이블 전체에 설정한 `Lock` 때문에 `DeadLock` 이 발생  
결국 `QueueNumber` 를 별도로 저장하는 테이블을 만들어서 해당 테이블의 `Row` 에 `Lock` 을 걸어 동시성 문제를 해결
- 동시성에 대한 경험이 부족하여 발생한 문제로, 데이터베이스 설계 부터 구현 까지 동시성을 고려하지 않고 작업 했기 때문에 이런 문제가 발생.
- `Redis`, `MQ` 등을 사용했다면, 좀 더 쉽게 해결이 되었을것 같지만 지금 주차에서는 `RDB` 만 사용해야 하기도 하고, 어떻게든 해결을 해보고 싶어 다양한 방법을 시도하다. 해당 방법을 통해 문제 해결

```kotlin
fun createEntryQueueToken(userId: UUID): String =
    Log.logging(logger) { log ->
        log["method"] = "createEntryQueueToken()"
        if (entryQueuePort.existsWaitingQueueToken(userId)) {
            throw QueueTokenException(ErrorCode.TOKEN_ALREADY_ISSUED, userId.toString())
        }
        transactional.run {
            val queueNumber: Int =
                entryQueuePort.getQueueNumberByIdForUpdate(NUMBER_ID)
            val entryQueueToken: String = jwtHelper.createJWT(userId, queueNumber)
            val queueToken =
                QueueToken(
                    userId = userId,
                    queueNumber = queueNumber,
                    token = entryQueueToken
                )
            entryQueuePort.saveEntryQueueToken(queueToken)
            entryQueuePort.incrementNextNumber(queueNumber + 1)
            entryQueueToken
        }
    }

internal interface EntryQueueNumberJpaRepository : JpaRepository<QueueNumberEntity, String> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT q FROM QueueNumberEntity q WHERE q.id = :id")
    fun findByIdForUpdate(
        @Param("id") id: String
    ): QueueNumberEntity?
}
```

- 동시성 문제를 해결한 코드, `getQueueNumberByIdForUpdate()` 메서드를 통해 비관적 락 이 설정되어 있는 `QueueNumbers` 테이블에서 `QueueNumber`를 조회 후  
해당 값으로 `Token` 을 발급하고 저장하는 방식으로 수정
