## 📜 캐시 전략 보고서

- 직접 일 단위 콘서트 예매율 랭킹 기능을 구현 후, 캐싱 전략을 선택하고 개선 보고서를 작성하고 싶었으나 락, 캐싱 학습 및 구현까지 진행하기에는  
일정 상 어려울것으로 판단되어 기능이 이미 구현되어 있음을 가정하고 보고서만 작성했습니다.

---

### 🚨 배경 & 문제 정의
- 현재 스키마(RDB)만으로 **일 단위 예매 랭킹(Top-N)**(공연/회차별 예매 건수·매출 기준)을 조회하려면 다음 조인이 필요함  
  `reservations`(CONFIRMED, confirmed_at) ↔ `concert_seats` ↔ `concert_schedules` ↔ `payments`
- 오픈런 등 피크 시간에는 집계 쿼리가 느려져 랭킹 API P95 지연이 커짐.
- 목표: **읽기 지연 < 20ms**, **근사 실시간(≤ 5초) 일관성**, **장애 시 자동 복구**.

---

### 💡 랭킹 정의(예)
- 지표: (A) 예매 건수, (B) 매출 합계
- 차원: (1) 공연(concert_id), (2) 회차(schedule_id)
- 기간: **일 단위(YYYY-MM-DD, Asia/Seoul)**
- 기능: Top-N, 페이지네이션, 특정 항목 현재 순위/점수 조회

---

### 🔥 RDB 베이스라인 쿼리(느린 이유)

```sql
-- 일일 매출 랭킹(회차 기준)
SELECT cs.id AS schedule_id,
       COUNT(DISTINCT r.id) AS orders,
       SUM(p.price)         AS revenue
FROM reservations r
JOIN concert_seats cse    ON r.concert_seat_id = cse.id
JOIN concert_schedules cs ON cse.schedule_id = cs.id
JOIN payments p           ON r.payment_id = p.id
WHERE r.status = 'CONFIRMED'
  AND p.status = 'COMPLETED'
  AND DATE(r.confirmed_at) = DATE(? /* YYYY-MM-DD */)
GROUP BY cs.id
ORDER BY revenue DESC
LIMIT 100;
```
- **병목**: 대량 `GROUP BY`, 다중 조인, 날짜 범위 스캔 → 인덱싱으로도 한계.
- **인덱스**: `reservations(status, confirmed_at)`, `reservations(concert_id, status, confirmed_at)`, `payments(status, paid_at)`

---

### 🖊️ Redis 캐시 모델링

#### 키 설계
- 날짜 버킷: `YYYYMMDD`
- 자료구조: **Sorted Set(ZSET)**
- 키(회차 기준): `rank:daily:schedule:{YYYYMMDD}`
- 멤버: `schedule_id`
- 랭킹 점수: 주문 수(`orders`) 또는 매출합(`revenue`)
- 메타 데이터: `hkey:schedule:{schedule_id}` Hash에 제목/일자/가격범위 등

#### 읽기 경로
- Top-N: `ZREVRANGE rank:daily:schedule:20250814 0 99 WITHSCORES`
- 순위/점수: `ZREVRANK`, `ZSCORE`
- 페이지네이션: `ZREVRANGE key start stop`
- 미스 처리: (a) 0으로 초기화 후 점진 반영, (b) 즉시 DB 리빌드 후 스왑

---

### 🔍 캐시 갱신 전략 비교

> 가정: **정확성 우선순위 < 지연시간**(근사 실시간 허용), **DB 트랜잭션 경계 외부에서 캐시 반영** 허용.

#### Cache-Aside (Lazy) + 주기 리빌드
- **쓰기 경로**: DB 커밋만 수행. 캐시는 읽을 때 없으면(또는 오래됨) **DB 집계→캐시에 set**.
- **장점**: 구현 단순. 장애 발생으로 캐시 데이터가 날아가도 안전.
- **단점**: 첫 조회가 느림(콜드 스타트), 피크 때 오히려 DB 부하 급증 가능.
- **적합도**: 랭킹처럼 **자주 읽히는 상위 N**에는 부적합.

#### Write-Through
- **쓰기 경로**: DB에 기록할 때 **동시에** Redis 업데이트(같은 요청 흐름에서).
- **장점**: 가장 최신을 데이터가 캐시에 저장. 클라이언트 즉시 최신 랭킹 반영.
- **단점**: 애플리케이션 지연 증가(네트워크/Redis 실패 전파), 분산 트랜잭션 문제.
- **적합도**: 강한 일관성을 꼭 원할 때.

#### Write-Behind (비동기 반영: Outbox + 워커)
- **쓰기 경로**: DB 트랜잭션 커밋 후 **Outbox 테이블**에 이벤트 삽입(동일 트랜잭션). 워커가 폴링/처리하여 Redis 갱신.
- **장점**: **요청 지연에 영향 거의 없음**, 재시도로 내구성, Redis 장애 시 버퍼링 가능.
- **단점**: **최대 지연(예: 1~5초)** 발생, 워커 운영 필요.
- **적합도**: 본 케이스(**랭킹**)에 최적.

#### Periodic Full Rebuild (주기적 전체 재계산)
- 크론/배치로 **N분/시간 단위** 전체 재빌드.
- **장점**: 구현 쉬움, 정합성 보정.
- **단점**: 최신성이 떨어짐, 배치 순간 부하 집중.
- **적합도**: **보정/검증 용** 보조 수단으로 권장.
