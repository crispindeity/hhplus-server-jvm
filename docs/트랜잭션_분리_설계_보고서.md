# 도메인별 서버/DB 분리 시 트랜잭션 처리 한계와 대응 방안

## 1. 배경
서비스 확장 과정에서 **모놀리식 아키텍처**의 한계를 극복하기 위해 도메인별로 애플리케이션 서버와 데이터베이스를 분리하는 전략을 선택하였다.  
예를 들어 다음과 같이 분리할 수 있다:

- **예약 도메인**: 예약 API 서버 + 예약 DB
- **결제 도메인**: 결제 API 서버 + 결제 DB
- **포인트 도메인**: 포인트 API 서버 + 포인트 DB

이러한 분리는 **도메인 독립성 강화**, **확장성 확보**, **장애 격리**에는 유리하지만, 기존 단일 DB에서 지원되던 **ACID 트랜잭션 보장**이 어려워지는 문제가 발생한다.

---

## 2. 트랜잭션 처리 한계

### 2.1 분산 트랜잭션 부재
- 단일 DB 환경에서는 `BEGIN ... COMMIT`으로 원자적 트랜잭션을 보장할 수 있었다.
- DB가 분리되면, 서로 다른 DB에 걸친 작업(예: 예약 생성 + 결제 승인)은 **분산 트랜잭션**이 필요하다.
- 하지만 일반적인 RDBMS는 DB 간 분산 트랜잭션을 직접 지원하지 않는다.

### 2.2 2PC(2-Phase Commit)의 한계
- 분산 트랜잭션을 구현하기 위해 2PC를 사용할 수 있으나 다음과 같은 문제가 있다:
    - 네트워크 지연 및 락 유지로 인한 성능 저하
    - Coordinator 장애 시 복구 어려움
    - 클라우드 네이티브 환경에서는 사실상 운영 비용이 과도

### 2.3 데이터 정합성 보장 어려움
- 예: 예약 성공 후 결제 실패 → 예약 DB에는 좌석이 점유된 상태로 남을 수 있음.
- 네트워크 장애, 서버 장애 등으로 인해 **중간 상태**가 장시간 유지될 수 있음.
- 트랜잭션 일관성 대신 **최종 일관성(Eventual Consistency)** 개념을 고려해야 한다.

---

## 3. 대응 방안

### 3.1 트랜잭션 범위 최소화
- 각 도메인 DB 내에서는 기존처럼 강력한 ACID 보장을 유지한다.
- DB를 넘어서는 트랜잭션은 보장하지 않고, 별도의 보상 메커니즘으로 해결한다.
- 예: 예약 도메인에서는 "좌석 임시 배정"까지만 처리하고, 결제 완료 이벤트가 수신되면 좌석을 최종 확정한다.

### 3.2 SAGA 패턴
#### (1) Choreography 기반 Saga
- 각 도메인이 이벤트를 발행하고, 다른 도메인이 이를 구독해 상태를 전이한다.
- 예시 흐름:
    1. 예약 서비스 → `SeatHeld` 이벤트 발행
    2. 결제 서비스 → 이벤트 수신 후 결제 시도
    3. 결제 성공 시 `PaymentCompleted` 이벤트 발행
    4. 예약 서비스 → `PaymentCompleted` 수신 후 좌석 확정
    5. 결제 실패 시 → `SeatReleased` 이벤트 발행하여 보상 처리

#### (2) Orchestration 기반 Saga
- 중앙 오케스트레이터(예약 서비스 또는 별도 Saga Coordinator)가 전체 프로세스를 관리한다.
- 각 도메인 서비스는 오케스트레이터의 명령에 따라 작업을 수행하고, 결과를 다시 보고한다.
- 장점: 흐름 제어가 명확
- 단점: 오케스트레이터가 단일 장애점(SPOF)이 될 수 있음

### 3.3 Outbox 패턴 & Eventual Consistency
- 서비스 내 로컬 트랜잭션으로 **DB 작업 + Outbox 테이블 기록**을 함께 커밋한다.
- 별도의 이벤트 퍼블리셔가 Outbox 테이블을 읽어 메시지 브로커(Kafka, RabbitMQ 등)에 전달한다.
- 다른 서비스는 브로커를 통해 이벤트를 수신하고 상태를 갱신한다.
- 이 방식으로 **중복 처리, 메시지 손실 방지**가 가능하다.

### 3.4 보상 트랜잭션 (Compensating Transaction)
- 실패 발생 시 원상 복구를 위한 보상 로직을 미리 정의한다.
- 예: 결제 실패 시 → 예약 취소, 포인트 환불
- 보상 트랜잭션도 실패할 수 있으므로, 멱등성(idempotency)을 고려해야 한다.

---

## 4. 아키텍처 설계 방안

### 4.1 이벤트 기반 아키텍처
- 서비스 간 직접 호출을 최소화하고, 메시지 브로커를 통한 비동기 이벤트 기반 통신을 채택한다.
- 예: 예약 서비스 → `SeatHeld` 이벤트 발행 → 브로커 → 결제 서비스 구독

### 4.2 트랜잭션 처리 시나리오 예시
#### [좌석 예약 + 결제]
1. 예약 서비스: 좌석 임시 배정 & 이벤트 발행 (`SeatHeld`)
2. 결제 서비스: 이벤트 수신 후 결제 진행
3. 결제 성공 → `PaymentCompleted` 발행
4. 예약 서비스: 이벤트 수신 후 좌석 확정 (`SeatConfirmed`)
5. 결제 실패 → `SeatReleased` 이벤트 발행, 임시 배정 해제

### 4.3 데이터 정합성 유지 전략
- **멱등성 보장**: 같은 이벤트가 여러 번 전달되어도 동일한 결과 유지
- **재시도 정책**: 실패한 이벤트는 일정 횟수/시간 간격으로 재시도
- **모니터링 및 알람**: 보상 트랜잭션 실패 시 운영자가 개입할 수 있도록 알림 체계 구축

---

## 5. 결론
- 도메인별 서버/DB 분리는 **확장성, 장애 격리, 독립 배포** 측면에서 필수적이지만, 분산 환경에서의 **트랜잭션 처리 한계**를 초래한다.
- **단일 DB 수준의 강한 일관성**을 유지하는 것은 불가능하며, 대신 **SAGA 패턴, Outbox 패턴, 보상 트랜잭션**을 통해 **최종 일관성(Eventual Consistency)**을 확보하는 것이 현실적인 대응 방안이다.
- 이는 마이크로서비스 아키텍처의 표준적인 설계 방향이며, 실제 운영 환경에서도 널리 적용되고 있다.
